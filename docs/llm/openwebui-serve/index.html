<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>OpenWebUI 셋업 방법 - ARCHIVE</title>
<meta name="description" content="">


  <meta name="author" content="hvppyarchive">
  
  <meta property="article:author" content="hvppyarchive">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ARCHIVE">
<meta property="og:title" content="OpenWebUI 셋업 방법">
<meta property="og:url" content="https://hvppyarchive.github.io/llm/openwebui-serve/">


  <meta property="og:description" content="">







  <meta property="article:published_time" content="2025-08-12T19:21:35+09:00">





  

  


<link rel="canonical" href="https://hvppyarchive.github.io/llm/openwebui-serve/">












<!-- end _includes/seo.html -->


<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->
<!-- hvppyarchive: add fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@200..900&display=swap" rel="stylesheet">

<!-- insert favicons. use https://realfavicongenerator.net/ -->
 <!-- hvppyarchive: add favicons -->
<link rel="icon" type="image/png" href="/assets/favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/assets/favicon/favicon.svg" />
<link rel="shortcut icon" href="/assets/favicon/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png" />
<link rel="manifest" href="/assets/favicon/site.webmanifest" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ARCHIVE
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/year-archive/"
                
                
              >Posts</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="OpenWebUI 셋업 방법">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="2025-08-12T19:21:35+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://hvppyarchive.github.io/llm/openwebui-serve/" itemprop="url">OpenWebUI 셋업 방법
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <!-- hvppyarchive: remove date icon
        <i class="far fa-calendar-alt" aria-hidden="true"></i> 
        -->
        
        <time datetime="2025-08-12T19:21:35+09:00">2025-08-12</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p class="chat--user">

endpoint 주소들을 이미 알고 있을 때 개인용 openwebui 셋업 하는 법 알려줘

</p>

<p>좋아요. “엔드포인트 주소는 이미 알고 있다”는 전제로, <strong>빠르게 개인용 Open WebUI</strong> 를 띄우고 각종(OpenAI·Ollama·vLLM·OpenRouter 등) <strong>커스텀 엔드포인트를 붙이는 최소 셋업</strong> 을 step‑by‑step으로 정리해드릴게요.</p>

<hr />

<h1 id="1-설치-방식-고르기-docker-추천">1) 설치 방식 고르기 (Docker 추천)</h1>

<p>가장 간단한 건 Docker입니다. Open WebUI 공식 퀵스타트도 Docker를 권장해요. <a href="https://docs.openwebui.com/getting-started/quick-start/?utm_source=chatgpt.com">Open WebUI</a></p>

<h3 id="a-docker-compose-권장">A. Docker Compose (권장)</h3>

<p>프로젝트 폴더에서 아래 파일을 저장하세요: <code class="language-plaintext highlighter-rouge">docker-compose.yml</code></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">openwebui</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">ghcr.io/open-webui/open-webui:main</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">openwebui</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:8080"</span>          <span class="c1"># 브라우저 접속은 http://localhost:3000</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./openwebui-data:/app/backend/data</span>   <span class="c1"># 채팅/설정 영속화</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="c1"># 필요 시 기본값만으로 시작하고, 이후 UI에서 세팅하는 것을 권장</span>
      <span class="c1"># 최초 실행 후 일부 항목은 'PersistentConfig'로 내부에 저장됩니다.</span>
      <span class="c1"># (아래 5) 참고)</span>
      <span class="na">WEBUI_URL</span><span class="pi">:</span> <span class="s2">"</span><span class="s">http://localhost:3000"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
</code></pre></div></div>

<p>실행:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
</code></pre></div></div>

<h3 id="b-단일-명령으로-실행docker-run">B. 단일 명령으로 실행(docker run)</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">--name</span> openwebui <span class="se">\</span>
  <span class="nt">-p</span> 3000:8080 <span class="se">\</span>
  <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/openwebui-data:/app/backend/data <span class="se">\</span>
  ghcr.io/open-webui/open-webui:main
</code></pre></div></div>

<p>공식 퀵스타트의 기본 흐름과 동일합니다. <a href="https://docs.openwebui.com/getting-started/quick-start/?utm_source=chatgpt.com">Open WebUI</a></p>

<hr />

<h1 id="2-최초-접속">2) 최초 접속</h1>

<p>브라우저에서 <code class="language-plaintext highlighter-rouge">http://localhost:3000</code>으로 들어가세요. 이후 계정/관리자 생성 절차는 기본 UI 흐름을 따릅니다(로그인/회원가입 토글 등은 환경변수로 제어 가능). 관련 일반/보안 변수는 “Environment Variable Configuration” 문서에 정리돼 있습니다. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>

<hr />

<h1 id="3-모델-제공자provider-추가--엔드포인트-붙이기">3) 모델 제공자(Provider) 추가 → “엔드포인트 붙이기”</h1>

<p>Open WebUI는 <strong>여러 개의 OpenAI‑호환/로컬 엔진 엔드포인트를 동시에 등록</strong> 할 수 있습니다.</p>

<h3 id="a-openai호환예-openai-openrouter-vllm-lm-studio-등">A. OpenAI‑호환(예: OpenAI, OpenRouter, vLLM, LM Studio 등)</h3>

<ol>
  <li>
    <p><strong>Settings → Models → Providers</strong> 로 이동</p>
  </li>
  <li>
    <p><strong>OpenAI Compatible</strong> 유형 추가</p>
  </li>
  <li>
    <p><strong>Base URL</strong>(이미 알고 계신 엔드포인트)과 <strong>API Key</strong> 입력 → 저장<br />
공식 “Starting With OpenAI” 가이드가 이 경로를 정확히 안내합니다. <a href="https://docs.openwebui.com/getting-started/quick-start/starting-with-openai/?utm_source=chatgpt.com">Open WebUI</a></p>
  </li>
</ol>

<blockquote>
  <p>팁: vLLM/LM Studio처럼 OpenAI‑호환 서버는 보통 <code class="language-plaintext highlighter-rouge">http(s)://HOST:PORT/v1</code> 형태의 Base URL을 씁니다. 모델 이름은 해당 서버에서 노출되는 이름 그대로 적어야 목록에 뜹니다(모델 리스트 캐시 TTL도 조정 가능). <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
</blockquote>

<h3 id="b-ollama로컬-사용-시">B. Ollama(로컬) 사용 시</h3>

<p>방법 2가지 중 편한 쪽으로:</p>

<ul>
  <li>
    <p><strong>UI에서</strong> Provider로 “Ollama” 추가 후 <strong>Base URL</strong>(예: <code class="language-plaintext highlighter-rouge">http://&lt;서버IP&gt;:11434</code>) 지정</p>
  </li>
  <li>
    <p><strong>환경변수로</strong> 미리 넘기기: <code class="language-plaintext highlighter-rouge">OLLAMA_BASE_URL=http://&lt;서버IP&gt;:11434</code><br />
공식 Ollama 연동 가이드 참조. <a href="https://docs.openwebui.com/getting-started/quick-start/starting-with-ollama/?utm_source=chatgpt.com">Open WebUI</a></p>
  </li>
</ul>

<blockquote>
  <p>주의: Docker로 분리 배치했다면 <code class="language-plaintext highlighter-rouge">127.0.0.1</code> 대신 <strong>컨테이너에서 접근 가능한 주소</strong>(예: 브리지 네트워크의 서비스명 또는 호스트 IP)를 써야 합니다. 모델 리스트 타임아웃/캐시는 <code class="language-plaintext highlighter-rouge">AIOHTTP_CLIENT_TIMEOUT_*</code>, <code class="language-plaintext highlighter-rouge">MODELS_CACHE_TTL</code>로 조절 가능합니다. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
</blockquote>

<hr />

<h1 id="4-선택-인증싱글유저도메인-설정">4) (선택) 인증/싱글유저/도메인 설정</h1>

<ul>
  <li>
    <p><strong>WEBUI_URL</strong> : OAuth/SSO 등을 쓸 계획이면 <strong>도메인으로 미리</strong> 지정하세요(중요). <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
  <li>
    <p>회원가입/로그인 폼 표시, 기본 역할 등은 <code class="language-plaintext highlighter-rouge">ENABLE_SIGNUP</code>, <code class="language-plaintext highlighter-rouge">ENABLE_LOGIN_FORM</code>, <code class="language-plaintext highlighter-rouge">DEFAULT_USER_ROLE</code> 등으로 제어합니다. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
</ul>

<hr />

<h1 id="5-환경변수와-persistentconfig-동작-이해중요">5) 환경변수와 “PersistentConfig” 동작 이해(중요)</h1>

<p>Open WebUI는 <strong>최초 기동 시점</strong> 에 일부 설정(‘PersistentConfig’ 표시된 항목)을 <strong>내부 DB에 영구 저장</strong> 합니다. 그 뒤에는 같은 환경변수를 바꿔도 내부 저장값이 우선됩니다. 필요하면 <code class="language-plaintext highlighter-rouge">ENABLE_PERSISTENT_CONFIG=False</code>로 비활성화하거나, <strong>관리자 UI에서 값을 변경</strong> 하세요. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>

<hr />

<h1 id="6-선택-외부-노출https-traefik-예시">6) (선택) 외부 노출/HTTPS (Traefik 예시)</h1>

<p>여러 서비스와 함께 쓰거나 Let’s Encrypt로 자동 HTTPS를 원하면 Traefik을 리버스 프록시로 두면 편합니다. Compose 예제와 기본 구성 흐름은 Traefik 문서에 잘 정리돼 있어요. <a href="https://doc.traefik.io/traefik/user-guides/docker-compose/basic-example/?utm_source=chatgpt.com">doc.traefik.io+1</a></p>

<hr />

<h1 id="7-업데이트백업">7) 업데이트/백업</h1>

<ul>
  <li>
    <p><strong>데이터 경로</strong> : <code class="language-plaintext highlighter-rouge">./openwebui-data</code> 볼륨에 채팅/설정이 저장됩니다(Compose 예제 기준).</p>
  </li>
  <li>
    <p>업데이트는 이미지 재풀/재시작으로 충분합니다. 설정 항목 대부분은 위 <strong>PersistentConfig 규칙</strong> 을 따릅니다. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
</ul>

<hr />

<h2 id="자주-막히는-포인트짧게">자주 막히는 포인트(짧게)</h2>

<ul>
  <li>
    <p><strong>모델이 안 보임</strong> : Base URL/키가 맞는지, 컨테이너 간 네트워크 경로가 맞는지 확인. 모델리스트 캐시/타임아웃 조정. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
  <li>
    <p><strong>로컬 Ollama 연결</strong> : Docker 분리 배치 시 <code class="language-plaintext highlighter-rouge">localhost</code> 대신 <strong>호스트 IP</strong> 또는 <strong>도커 네트워크의 서비스명</strong> 사용. <a href="https://docs.openwebui.com/getting-started/quick-start/starting-with-ollama/?utm_source=chatgpt.com">Open WebUI</a></p>
  </li>
</ul>

<hr />

<p>필요하시면 <strong>현재 가지고 계신 엔드포인트(Base URL/키/모델명) 조합</strong> 에 맞춰 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>을 바로 맞춤 생성해 드릴게요.</p>

<p class="chat--user">

pip 설치 방식으로 가이드해줘

</p>

<p>좋습니다. pip 기반으로 Open WebUI를 설치하고, 이미 알고 계신 엔드포인트를 붙이는 방법을 단계별로 정리해드릴게요.</p>

<hr />

<h2 id="1-python-환경-준비">1) Python 환경 준비</h2>

<ul>
  <li><strong>Python 3.10 이상</strong> 이 필요합니다. (venv 권장)</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> venv .venv
<span class="nb">source</span> .venv/bin/activate
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
</code></pre></div></div>

<hr />

<h2 id="2-open-webui-설치">2) Open WebUI 설치</h2>

<p>공식 저장소에서 PyPI 배포 버전을 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>open-webui
</code></pre></div></div>

<p>설치 후, CLI 명령어 <code class="language-plaintext highlighter-rouge">open-webui</code>가 등록됩니다.</p>

<hr />

<h2 id="3-실행">3) 실행</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open-webui serve
</code></pre></div></div>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8080</code>에서 실행됩니다.<br />
원한다면 포트 변경:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open-webui serve <span class="nt">--port</span> 3000
</code></pre></div></div>

<hr />

<h2 id="4-최초-접속--관리자-계정-생성">4) 최초 접속 &amp; 관리자 계정 생성</h2>

<p>브라우저에서 <code class="language-plaintext highlighter-rouge">http://localhost:3000</code> → 첫 로그인 시 관리자 계정을 만듭니다.</p>

<hr />

<h2 id="5-엔드포인트-등록-openai-호환--ollama-등">5) 엔드포인트 등록 (OpenAI 호환 / Ollama 등)</h2>

<h3 id="a-ui에서-설정">A. UI에서 설정</h3>

<ol>
  <li>
    <p><strong>Settings → Models → Providers</strong></p>
  </li>
  <li>
    <p><strong>Add Provider</strong> → "OpenAI Compatible" 선택</p>
  </li>
  <li>
    <p><strong>Base URL</strong> : 알고 계신 엔드포인트 주소 입력</p>
  </li>
  <li>
    <p><strong>API Key</strong> : 해당 서비스의 키 입력</p>
  </li>
  <li>
    <p>저장 후 모델 목록을 불러와 선택</p>
  </li>
</ol>

<blockquote>
  <p>vLLM/LM Studio의 경우 Base URL이 <code class="language-plaintext highlighter-rouge">http://HOST:PORT/v1</code> 형식인 경우가 많습니다.</p>
</blockquote>

<hr />

<h3 id="b-환경변수로-미리-세팅-선택">B. 환경변수로 미리 세팅 (선택)</h3>

<p>실행 전에 아래 예시처럼 환경변수를 설정하면 UI에서 자동으로 반영됩니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">OPENAI_API_BASE_URL</span><span class="o">=</span><span class="s2">"https://your-endpoint.example.com/v1"</span>
<span class="nb">export </span><span class="nv">OPENAI_API_KEY</span><span class="o">=</span><span class="s2">"sk-xxxxxxxxxxxxxxxx"</span>
open-webui serve
</code></pre></div></div>

<p>Ollama 사용 시:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">OLLAMA_BASE_URL</span><span class="o">=</span><span class="s2">"http://localhost:11434"</span>
</code></pre></div></div>

<hr />

<h2 id="6-데이터-영속화">6) 데이터 영속화</h2>

<p>pip 실행은 기본적으로 현재 디렉터리의 <code class="language-plaintext highlighter-rouge">.open-webui</code> 폴더에 데이터(채팅 기록, 설정)를 저장합니다.</p>

<ul>
  <li>다른 위치에 저장하려면:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open-webui serve <span class="nt">--data-dir</span> /path/to/data
</code></pre></div></div>

<hr />

<h2 id="7-선택-https--외부-접근">7) (선택) HTTPS &amp; 외부 접근</h2>

<ul>
  <li>
    <p>로컬에서만 쓰는 경우 무관하지만, 외부 접근 시 <strong>리버스 프록시(Nginx/Traefik)</strong> + HTTPS 적용을 권장합니다.</p>
  </li>
  <li>
    <p>도메인 기반 접근 시 <code class="language-plaintext highlighter-rouge">WEBUI_URL</code> 환경변수를 세팅하면 OAuth/SSO 연동 시 편합니다.</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">WEBUI_URL</span><span class="o">=</span><span class="s2">"https://chat.example.com"</span>
</code></pre></div></div>

<hr />

<h2 id="8-업데이트">8) 업데이트</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">--upgrade</span> open-webui
</code></pre></div></div>

<hr />

<p>원하시면 제가 <strong>pip 설치용 + 환경변수 엔드포인트 자동 세팅이 포함된 실행 스크립트</strong> 를 만들어 드릴 수 있습니다.<br />
그렇게 하면 매번 UI에서 입력할 필요 없이 엔드포인트와 키가 자동 등록된 상태로 Open WebUI가 실행됩니다.</p>

<p class="chat--user">

Your system has an unsupported version of sqlite3. Chroma requires sqlite3 &gt;= 3.35.0

</p>

<p>이 오류는 Open WebUI가 내부에서 사용하는 <strong>Chroma DB</strong> 가 최신 SQLite 기능(3.35.0 이상)을 요구하는데,<br />
현재 OS에 설치된 Python이 <strong>너무 구버전 SQLite</strong> 를 내장하고 있어서 발생하는 문제입니다.</p>

<p><code class="language-plaintext highlighter-rouge">pip install</code>로 설치했을 때 Python은 <strong>내장된 sqlite3 라이브러리</strong> 를 사용하므로, OS에 sqlite3을 새로 깔아도 Python이 그걸 자동으로 쓰지 않습니다.<br />
해결 방법은 크게 두 가지가 있습니다.</p>

<hr />

<h2 id="1-python-자체를-최신-빌드로-교체-권장">1) Python 자체를 최신 빌드로 교체 (권장)</h2>

<p>가장 깔끔한 방법입니다. Python 3.10+ 최신 빌드는 sqlite3 3.35.0 이상을 포함합니다.</p>

<p><strong>Ubuntu/Debian 예시</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>python3.11 python3.11-venv python3.11-dev
</code></pre></div></div>

<p>그리고 새 venv에서 다시 설치:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3.11 <span class="nt">-m</span> venv .venv
<span class="nb">source</span> .venv/bin/activate
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
pip <span class="nb">install </span>open-webui
</code></pre></div></div>

<p><strong>macOS(Homebrew) 예시</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>python@3.11
brew <span class="nb">link </span>python@3.11 <span class="nt">--force</span>
</code></pre></div></div>

<hr />

<h2 id="2-os에-최신-sqlite3-설치-후-python-재빌드">2) OS에 최신 sqlite3 설치 후 Python 재빌드</h2>

<p>만약 Python 버전을 그대로 쓰고 싶다면:</p>

<ol>
  <li>
    <p>최신 sqlite3 설치</p>

    <ul>
      <li>Ubuntu/Debian:
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>sqlite3 libsqlite3-dev
</code></pre></div>        </div>
      </li>
      <li>macOS:
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>sqlite
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Python을 재빌드하여 새 sqlite3을 링크<br />
(소스 빌드 시 <code class="language-plaintext highlighter-rouge">libsqlite3-dev</code>를 설치한 상태여야 함)</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv <span class="nb">install </span>3.11.9
pyenv global 3.11.9
</code></pre></div>    </div>
  </li>
</ol>

<hr />

<h2 id="3-conda-환경을-이용-간단-대안">3) conda 환경을 이용 (간단 대안)</h2>

<p>conda는 최신 sqlite를 자동 포함하므로, 설치가 간단합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">-n</span> openwebui <span class="nv">python</span><span class="o">=</span>3.11
conda activate openwebui
pip <span class="nb">install </span>open-webui
</code></pre></div></div>

<hr />

<p>💡 <strong>추천 순서</strong></p>

<ol>
  <li>
    <p>가능하면 Python을 최신으로 갈아타세요(방법 1).</p>
  </li>
  <li>
    <p>OS-level sqlite만 업데이트해선 해결 안 되니, Python 재설치/재빌드가 필요합니다.</p>
  </li>
  <li>
    <p>복잡하면 conda로 환경 만드는 게 제일 빠릅니다.</p>
  </li>
</ol>

<hr />

<p>원하시면 제가 <strong>현재 OS/Python 버전과 sqlite 버전 확인 명령</strong> 을 드려서<br />
지금 환경에서 어떤 경로가 제일 빠른지 바로 판단해드릴 수 있습니다.<br />
그걸 해드릴까요?</p>

<p class="chat--user">

현재 설치된 sqlite3 버전 보는 법 알려줘. 내가 설치한 파이썬이 3.11.12 라서 상당히 최신 버전인데. venv로 가상환경 만들어서 하고 있는데 이게 이슈가 될 수도 있나?

</p>

<p>네, Python 3.11.12면 상당히 최신이지만,<br />
<strong>venv 환경 안에서도 Python이 빌드될 때 포함된 SQLite 버전</strong> 을 그대로 쓰기 때문에,<br />
OS의 sqlite 버전과는 별개로 문제가 날 수 있습니다.</p>

<p>확인 방법은 두 가지가 있습니다.</p>

<hr />

<h2 id="1-python이-쓰는-sqlite3-버전-확인">1) Python이 쓰는 sqlite3 버전 확인</h2>

<p>가상환경 안에서 아래 명령 실행:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>
</code></pre></div></div>

<p>이 값이 <strong>3.35.0 이상</strong> 이어야 Chroma가 동작합니다.</p>

<hr />

<h2 id="2-os-시스템-sqlite-버전-확인-참고">2) OS 시스템 sqlite 버전 확인 (참고)</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlite3 <span class="nt">--version</span>
</code></pre></div></div>

<p>이건 OS에 설치된 <code class="language-plaintext highlighter-rouge">sqlite3</code> CLI 버전입니다.<br />
Python 내부에서 사용하는 라이브러리 버전과 다를 수 있습니다.</p>

<hr />

<p>💡 <strong>중요 포인트</strong></p>

<ul>
  <li>
    <p>venv는 <strong>현재 Python 실행 파일</strong> 과 그에 내장된 sqlite3를 그대로 복사해서 씁니다.</p>
  </li>
  <li>
    <p>따라서 Python 3.11이라도, 해당 Python이 구버전 sqlite로 빌드되었으면 venv 안에서도 그대로 구버전을 씁니다.</p>
  </li>
  <li>
    <p>해결하려면 최신 sqlite로 빌드된 Python을 쓰거나(예: pyenv, conda), 시스템 Python을 교체해야 합니다.</p>
  </li>
</ul>

<hr />

<p>원하시면 제가 <strong>현재 venv에서 동작하는 sqlite 버전 확인 후, 바로 업그레이드 방법</strong> 까지 이어서 정리해 드릴까요?<br />
그러면 바로 Chroma 오류도 해결됩니다.</p>

<p class="chat--user">

그렇네 둘 다 3.26.0 으로 되고 있어. 내가 sudo 권한도 없고 인터넷 연결도 안 된 redhat 8.x OS야. 이거에 맞춰서 sqlite3 설치하고 파이썬 3.11 버전 다시 빌드 하는 방법 차근차근 알려줘

</p>

<p>좋아요—<strong>sudo 없음 + 외부 인터넷 없음 + RHEL 8.x</strong> 환경을 전제로, <strong>사용자 홈 디렉터리</strong> 에 최신 sqlite3를 소스에서 설치하고, 그걸 링크해서 <strong>Python 3.11을 다시 빌드</strong> 하는 절차를 <strong>완전 오프라인</strong> 기준으로 차근차근 정리했습니다.<br />
(핵심은: Python이 링크하는 sqlite를 3.35.0 이상으로 교체하는 것!)</p>

<hr />

<h1 id="전체-흐름-한눈에">전체 흐름 한눈에</h1>

<ol>
  <li>
    <p>다른 네트워크 가능한 PC에서 <strong>소스 tar.gz</strong> 받아오기 → 사내망/USB로 서버에 복사</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$HOME/opt/sqlite-&lt;버전&gt;</code>에 sqlite3 설치 (사용자 권한)</p>
  </li>
  <li>
    <p>그 sqlite를 가리키도록 <strong>환경변수(헤더/라이브러리 경로)</strong> 잡고 Python 3.11.12를 <strong>재빌드 + 사용자 경로에 설치</strong></p>
  </li>
  <li>
    <p>새 Python으로 venv 다시 만들고, <code class="language-plaintext highlighter-rouge">python -c "import sqlite3; print(sqlite3.sqlite_version)"</code>가 <strong>3.35+</strong>인지 확인</p>
  </li>
</ol>

<hr />

<h1 id="0-준비-디렉터리변수">0) 준비: 디렉터리/변수</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 홈 디렉터리 아래에 설치 경로를 잡습니다.</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/src <span class="nv">$HOME</span>/opt
<span class="c"># 아래 버전은 예시입니다. (3.45.3 등 3.35.0 이상이면 OK)</span>
<span class="nb">export </span><span class="nv">SQLITE_VER</span><span class="o">=</span>3.45.4
<span class="nb">export </span><span class="nv">PY_VER</span><span class="o">=</span>3.11.12

<span class="c"># 설치 prefix</span>
<span class="nb">export </span><span class="nv">SQLITE_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/sqlite-</span><span class="nv">$SQLITE_VER</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">PY_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/python-</span><span class="nv">$PY_VER</span><span class="s2">"</span>
</code></pre></div></div>

<hr />

<h1 id="1-오프라인-파일-준비-다른-pc에서-다운로드">1) 오프라인 파일 준비 (다른 PC에서 다운로드)</h1>

<p>외부 인터넷 가능한 PC에서 아래 두 개(이상)를 받아 USB/사내망으로 <strong>서버의<code class="language-plaintext highlighter-rouge">$HOME/src</code></strong> 로 옮깁니다.</p>

<ul>
  <li>
    <p><strong>SQLite</strong> : <code class="language-plaintext highlighter-rouge">sqlite-autoconf-&lt;X&gt;.tar.gz</code></p>

    <ul>
      <li>
        <p>파일명 숫자 <code class="language-plaintext highlighter-rouge">&lt;X&gt;</code>는 버전 넘버를 붙인 값입니다. 예: 3.45.4 → <code class="language-plaintext highlighter-rouge">3450400</code></p>
      </li>
      <li>
        <p>예시 파일명: <code class="language-plaintext highlighter-rouge">sqlite-autoconf-3450400.tar.gz</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Python 3.11.12</strong> : <code class="language-plaintext highlighter-rouge">Python-3.11.12.tgz</code></p>
  </li>
</ul>

<blockquote>
  <p>(선택) pip를 쓸 계획이면, 나중에 필요한 패키지들 <strong>whl/tar.gz</strong> 도 같이 받아오세요. 오프라인 설치 시 <code class="language-plaintext highlighter-rouge">pip install --no-index --find-links</code>로 설치합니다.</p>
</blockquote>

<p>서버에 파일이 도착하면:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-1</span> <span class="nv">$HOME</span>/src
<span class="c"># sqlite-autoconf-3450400.tar.gz</span>
<span class="c"># Python-3.11.12.tgz</span>
</code></pre></div></div>

<hr />

<h1 id="2-sqlite3-335-사용자-디렉터리에-빌드설치">2) sqlite3 (&gt;=3.35) 사용자 디렉터리에 빌드/설치</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span>/src
<span class="nb">tar </span>xf sqlite-autoconf-3450400.tar.gz
<span class="nb">cd </span>sqlite-autoconf-3450400

<span class="c"># fPIC으로 빌드, prefix는 사용자 디렉터리</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> ./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>

<span class="c"># 설치 확인</span>
<span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/bin/sqlite3"</span> <span class="nt">--version</span>
<span class="c"># 3.45.4 ... 같이 3.35.0 이상이 출력되어야 합니다.</span>
</code></pre></div></div>

<hr />

<h1 id="3-python-31112를-새-sqlite에-링크해서-재빌드설치">3) Python 3.11.12를 새 sqlite에 링크해서 재빌드/설치</h1>

<p>Python이 새 sqlite 헤더/라이브러리를 보도록 <strong>컴파일 환경변수</strong> 를 줍니다. 또한 실행 시 라이브러리 탐색이 되도록 <strong>rpath</strong> 를 심어두면 편합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span>/src
<span class="nb">tar </span>xf Python-3.11.12.tgz
<span class="nb">cd </span>Python-3.11.12

<span class="c"># 컴파일러가 새 sqlite를 찾도록 경로 지정</span>
<span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">"-I</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/include"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib -Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>

<span class="c"># 최적화/ensurepip 포함하여 빌드</span>
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">--enable-optimizations</span> <span class="se">\</span>
  <span class="nt">--with-lto</span> <span class="se">\</span>
  <span class="nt">--with-ensurepip</span><span class="o">=</span><span class="nb">install

</span>make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="빌드가-끝난-뒤-경로-적용--버전-확인">빌드가 끝난 뒤 경로 적용 &amp; 버전 확인</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 새 파이썬을 PATH 앞에 두기 (쉘 프로필에 추가 권장)</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>

<span class="c"># 파이썬이 바라보는 sqlite 버전 확인</span>
python3 <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>
<span class="c"># =&gt; 3.45.4 (또는 3.35.0 이상) 가 나와야 성공</span>
</code></pre></div></div>

<blockquote>
  <p>만약 위에서 여전히 3.26.0이 나온다면, Python이 새 sqlite를 못 찾은 것입니다.</p>

  <ul>
    <li>
      <p><code class="language-plaintext highlighter-rouge">CPPFLAGS/LDFLAGS/LD_LIBRARY_PATH</code>가 올바른지 점검</p>
    </li>
    <li>
      <p>아래 “문제 해결 팁”의 <strong>A. _sqlite3 모듈 강제 구성</strong> 을 참고해 모듈을 명시적으로 빌드</p>
    </li>
  </ul>

</blockquote>

<hr />

<h1 id="4-새-python으로-venv-다시-만들기-중요">4) 새 Python으로 venv 다시 만들기 (중요)</h1>

<p>기존 venv는 <strong>예전 파이썬 바이너리/라이브러리</strong> 를 기준으로 만들어졌기 때문에 <strong>새로 만들어야</strong> 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (선택) 이전 venv 비활성화</span>
deactivate 2&gt;/dev/null <span class="o">||</span> <span class="nb">true</span>

<span class="c"># 새 venv 생성</span>
python3 <span class="nt">-m</span> venv <span class="nv">$HOME</span>/venvs/openwebui
<span class="nb">source</span> <span class="nv">$HOME</span>/venvs/openwebui/bin/activate

<span class="c"># pip 자체 업그레이드 (오프라인이면 생략)</span>
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip

<span class="c"># 최종 확인 (venv 내부에서도)</span>
python <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>
<span class="c"># =&gt; 3.35.0 이상인지 재확인</span>
</code></pre></div></div>

<p>이제 이 venv에서 Open WebUI/Chroma를 쓰면 <strong>sqlite 버전 오류 없이</strong> 동작합니다.</p>

<hr />

<h1 id="5-오프라인-pip-설치-팁">5) (오프라인) pip 설치 팁</h1>

<p>외부에서 의존성들을 미리 받아 왔다면:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 오프라인 저장소 폴더(예: /path/pkgs)에 whl/tar.gz 모아둔 경우</span>
pip <span class="nb">install</span> <span class="nt">--no-index</span> <span class="nt">--find-links</span> /path/pkgs open-webui
</code></pre></div></div>

<ul>
  <li>
    <p>SSL 모듈(_ssl) 없이 빌드했다면 <strong>https 다운로드는 불가</strong> 하므로, 필요한 패키지는 <strong>사전 다운로드</strong> 가 필요합니다.</p>
  </li>
  <li>
    <p>나중에 인터넷이 가능해지면 OpenSSL 헤더/라이브러리를 사용자 영역에 빌드한 뒤, Python을 다시 빌드해 <code class="language-plaintext highlighter-rouge">_ssl</code> 모듈을 붙일 수 있습니다(옵션).</p>
  </li>
</ul>

<hr />

<h2 id="문제-해결-팁-troubleshooting">문제 해결 팁 (Troubleshooting)</h2>

<h3 id="a-_sqlite3-모듈이-not-found로-스킵되는-경우">A) <code class="language-plaintext highlighter-rouge">_sqlite3</code> 모듈이 “not found”로 스킵되는 경우</h3>

<p>Python 빌드 로그 마지막 부분에 “The necessary bits to build these optional modules were not found” 목록에 <code class="language-plaintext highlighter-rouge">_sqlite3</code>가 포함되어 있으면, SQLite 헤더/라이브러리를 못 찾은 것입니다. 가장 확실한 방법은 <strong>모듈 빌드 지시를 명시</strong> 하는 것입니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span>/src/Python-3.11.12/Modules

<span class="c"># Setup.local 파일에 명시적으로 _sqlite3 모듈 빌드 지시 추가</span>
<span class="nb">cat</span> <span class="o">&gt;</span> Setup.local <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
_sqlite3 _sqlite/module.c -I</span><span class="nv">$SQLITE_PREFIX</span><span class="sh">/include -L</span><span class="nv">$SQLITE_PREFIX</span><span class="sh">/lib -lsqlite3
</span><span class="no">EOF

</span><span class="c"># 환경변수는 여전히 설정된 상태여야 함 (CPPFLAGS/LDFLAGS/LD_LIBRARY_PATH)</span>
<span class="nb">cd</span> ..
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>다시 <code class="language-plaintext highlighter-rouge">python -c "import sqlite3; print(sqlite3.sqlite_version)"</code>로 확인해 보세요.</p>

<h3 id="b-매번-ld_library_path-잡기-싫을-때">B) 매번 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 잡기 싫을 때</h3>

<p>위에서 <code class="language-plaintext highlighter-rouge">LDFLAGS="-Wl,-rpath,$SQLITE_PREFIX/lib"</code>를 줬다면 보통은 필요 없습니다.<br />
혹시 빠뜨렸다면, 아래처럼 <strong>rpath 포함 재빌드</strong> 하거나, 셸 프로필(<code class="language-plaintext highlighter-rouge">~/.bashrc</code>)에 다음을 추가하세요.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>
</code></pre></div></div>

<h3 id="c-여러-버전-공존">C) 여러 버전 공존</h3>

<ul>
  <li>
    <p>다른 작업에 시스템 Python이 필요하면, 단순히 PATH/LD_LIBRARY_PATH를 <strong>활성화/비활성화</strong> 하여 전환하면 됩니다.</p>
  </li>
  <li>
    <p>충돌을 피하려면 항상 <code class="language-plaintext highlighter-rouge">which python</code>으로 현재 쓰는 바이너리가 어디인지 확인하세요.</p>
  </li>
</ul>

<hr />

<h2 id="최종-체크리스트">최종 체크리스트</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$SQLITE_PREFIX/bin/sqlite3 --version</code>이 <strong>3.35+</strong></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">python -c "import sqlite3; print(sqlite3.sqlite_version)"</code>가 <strong>3.35+</strong></p>
  </li>
  <li>
    <p>새 <strong>venv</strong> 에서 동일 결과 확인</p>
  </li>
  <li>
    <p>Open WebUI/Chroma 다시 실행 시 더 이상 <code class="language-plaintext highlighter-rouge">sqlite3 &gt;= 3.35.0</code> 에러가 나오지 않음</p>
  </li>
</ul>

<p>필요하면, 위 과정을 <strong>복붙 가능한 스크립트</strong>(버전/경로만 변수로 바꾸면 되는 형태)로 만들어 드릴게요.</p>

<p class="chat--user">

혹시 이거 말고 다른 dependency가 있을까? 미리 다 준비해서 한 번에 설치하고 싶어.

</p>

<p>좋은 질문이에요. “한 번에” 끝내려면 <strong>(A) Python 자체를 빌드할 때 필요한 네이티브 라이브러리</strong> 와 <strong>(B) Open WebUI/Chroma 파이썬 패키지 측 의존성(가능하면 휠로 미리 받아오기)</strong> 두 축으로 준비하면 됩니다. 아래를 <strong>차근차근</strong> 따라오세요.</p>

<hr />

<h1 id="a-python-311을-기능-빠짐없이-빌드하기-위한-네이티브-의존성">A) Python 3.11을 기능 빠짐없이 빌드하기 위한 네이티브 의존성</h1>

<blockquote>
  <p>목표: <code class="language-plaintext highlighter-rouge">_sqlite3</code>, <code class="language-plaintext highlighter-rouge">_ssl</code>, <code class="language-plaintext highlighter-rouge">_bz2</code>, <code class="language-plaintext highlighter-rouge">_lzma</code>, <code class="language-plaintext highlighter-rouge">_readline</code>, <code class="language-plaintext highlighter-rouge">ctypes</code> 등 <strong>표준 모듈이 빠지지 않게</strong> 하려면, 해당 C 라이브러리를 <strong>사용자 경로</strong> 에 먼저 설치하고, 그 경로를 가리키며 Python을 빌드해야 합니다. (sudo/인터넷 없음 가정)</p>
</blockquote>

<p>필수/강력권장 라이브러리:</p>

<table>
  <thead>
    <tr>
      <th>라이브러리</th>
      <th>기능(파이썬 내 모듈)</th>
      <th>없을 때 증상</th>
      <th>오프라인 준비 요령(요지)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>OpenSSL ≥1.1.1/3.0</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ssl</code>, <code class="language-plaintext highlighter-rouge">hashlib</code> 가속</td>
      <td>HTTPS 불가 → pip 다운로드/인증서 문제</td>
      <td>소스 tar.gz → <code class="language-plaintext highlighter-rouge">$HOME/opt/openssl-&lt;ver&gt;</code>에 설치 후 <code class="language-plaintext highlighter-rouge">./configure</code> 시 <code class="language-plaintext highlighter-rouge">--with-openssl</code> 또는 <code class="language-plaintext highlighter-rouge">CPPFLAGS/LDFLAGS</code>로 경로 지정</td>
    </tr>
    <tr>
      <td><strong>zlib</strong></td>
      <td><code class="language-plaintext highlighter-rouge">zlib</code></td>
      <td>압축 관련 일부 기능 제한</td>
      <td><code class="language-plaintext highlighter-rouge">zlib</code> 소스 빌드 → <code class="language-plaintext highlighter-rouge">$HOME/opt/zlib</code></td>
    </tr>
    <tr>
      <td><strong>bzip2 (libbz2)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">_bz2</code></td>
      <td><code class="language-plaintext highlighter-rouge">.bz2</code> 핸들링 불가</td>
      <td><code class="language-plaintext highlighter-rouge">bzip2</code> 소스 빌드 → <code class="language-plaintext highlighter-rouge">$HOME/opt/bzip2</code></td>
    </tr>
    <tr>
      <td><strong>xz (liblzma)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">_lzma</code></td>
      <td><code class="language-plaintext highlighter-rouge">.xz</code> 핸들링 불가</td>
      <td><code class="language-plaintext highlighter-rouge">xz</code>(xz-utils) 소스 빌드 → <code class="language-plaintext highlighter-rouge">$HOME/opt/xz</code></td>
    </tr>
    <tr>
      <td><strong>readline + ncurses</strong></td>
      <td><code class="language-plaintext highlighter-rouge">readline</code></td>
      <td>REPL 히스토리/라인편집 미작동</td>
      <td><code class="language-plaintext highlighter-rouge">readline</code>, <code class="language-plaintext highlighter-rouge">ncurses</code> 소스 빌드</td>
    </tr>
    <tr>
      <td><strong>libffi</strong></td>
      <td><code class="language-plaintext highlighter-rouge">_ctypes</code></td>
      <td><code class="language-plaintext highlighter-rouge">ctypes</code> 미구성</td>
      <td><code class="language-plaintext highlighter-rouge">libffi</code> 소스 빌드</td>
    </tr>
    <tr>
      <td><strong>sqlite3 ≥3.35</strong></td>
      <td><code class="language-plaintext highlighter-rouge">_sqlite3</code></td>
      <td>(이미 보신) Chroma 에러</td>
      <td>위에서 진행하신 대로 소스 빌드</td>
    </tr>
    <tr>
      <td><strong>expat</strong></td>
      <td><code class="language-plaintext highlighter-rouge">pyexpat</code></td>
      <td>XML 파싱 미동작</td>
      <td><code class="language-plaintext highlighter-rouge">expat</code> 소스 빌드</td>
    </tr>
    <tr>
      <td><strong>gdbm</strong>(선택)</td>
      <td><code class="language-plaintext highlighter-rouge">dbm.gnu</code></td>
      <td>GNU DBM 미사용</td>
      <td>필요 시만</td>
    </tr>
    <tr>
      <td><strong>uuid</strong>(libuuid, 선택)</td>
      <td><code class="language-plaintext highlighter-rouge">uuid</code>(OS 백엔드)</td>
      <td>순수 파이썬 대체</td>
      <td>선택</td>
    </tr>
  </tbody>
</table>

<h3 id="설치-순서권장">설치 순서(권장)</h3>

<ol>
  <li>
    <p>zlib → bzip2 → xz → readline/ncurses → libffi → <strong>sqlite</strong> → <strong>OpenSSL</strong> → expat</p>
  </li>
  <li>
    <p>각 라이브러리마다 <code class="language-plaintext highlighter-rouge">--prefix="$HOME/opt/&lt;name&gt;-&lt;ver&gt;"</code>로 설치</p>
  </li>
  <li>
    <p>Python 빌드 전에 아래처럼 경로를 한 번에 잡습니다:</p>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PKGROOTS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/zlib:</span><span class="nv">$HOME</span><span class="s2">/opt/bzip2:</span><span class="nv">$HOME</span><span class="s2">/opt/xz:</span><span class="nv">$HOME</span><span class="s2">/opt/readline:</span><span class="nv">$HOME</span><span class="s2">/opt/ncurses:</span><span class="nv">$HOME</span><span class="s2">/opt/libffi:</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">:</span><span class="nv">$HOME</span><span class="s2">/opt/openssl:</span><span class="nv">$HOME</span><span class="s2">/opt/expat"</span>
<span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">printf</span> <span class="nt">--</span> <span class="s1">' -I%s/include'</span> <span class="k">${</span><span class="nv">PKGROOTS</span><span class="p">//</span>:/<span class="p"> </span><span class="k">}</span><span class="si">)</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">printf</span> <span class="nt">--</span> <span class="s1">' -L%s/lib'</span> <span class="k">${</span><span class="nv">PKGROOTS</span><span class="p">//</span>:/<span class="p"> </span><span class="k">}</span><span class="si">)</span><span class="s2"> -Wl,-rpath,</span><span class="nv">$HOME</span><span class="s2">/opt/zlib/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/bzip2/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/xz/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/readline/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/ncurses/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/libffi/lib:</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/openssl/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/expat/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/zlib/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/bzip2/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/xz/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/readline/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/ncurses/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/libffi/lib:</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/openssl/lib:</span><span class="nv">$HOME</span><span class="s2">/opt/expat/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>
</code></pre></div></div>

<ol>
  <li>그런 다음 Python <code class="language-plaintext highlighter-rouge">./configure</code>:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">--enable-optimizations</span> <span class="nt">--with-lto</span> <span class="se">\</span>
  <span class="nt">--with-ensurepip</span><span class="o">=</span><span class="nb">install</span> <span class="se">\</span>
  <span class="nt">--with-openssl</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/openssl-&lt;ver&gt;"</span>  <span class="c"># 있으면 명시, 없으면 CPP/LDFLAGS에 의존</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
</code></pre></div></div>

<ol>
  <li>빌드 후 확인(반드시 venv 새로 생성):<br />
<code class="language-plaintext highlighter-rouge">python -c "import sqlite3, ssl, bz2, lzma, readline, ctypes, xml.parsers.expat as e; print(sqlite3.sqlite_version, ssl.OPENSSL_VERSION)"</code></li>
</ol>

<blockquote>
  <p><strong>팁</strong> : <code class="language-plaintext highlighter-rouge">_sqlite3</code>처럼 빠지는 모듈이 있다면, 위 경로/변수 누락이 원인입니다. 필요하면 <code class="language-plaintext highlighter-rouge">Modules/Setup.local</code>에 모듈 빌드 라인(예: <code class="language-plaintext highlighter-rouge">_sqlite3 ... -lsqlite3</code>)을 <strong>명시</strong> 하고 <code class="language-plaintext highlighter-rouge">make install</code>을 다시 실행하세요.</p>
</blockquote>

<hr />

<h1 id="b-open-webui--chroma-파이썬-패키지-쪽-의존성오프라인-휠-준비">B) Open WebUI / Chroma 파이썬 패키지 쪽 의존성(오프라인 휠 준비)</h1>

<blockquote>
  <p>목표: RHEL 8.x + Python 3.11에서 <strong>빌드 없이 설치</strong> 되도록, 가능한 한 <strong>미리 컴파일된 wheel</strong>(manylinux2014_x86_64 등)을 모아 <strong>오프라인 저장소</strong>(wheelhouse)를 준비합니다. (sudo/인터넷 없음 가정)</p>
</blockquote>

<h3 id="1-핵심-패키지">1) 핵심 패키지</h3>

<ul>
  <li>
    <p><strong>open-webui</strong> (백엔드 FastAPI/uvicorn 등 포함)</p>
  </li>
  <li>
    <p><strong>chromadb</strong> (벡터DB: SQLite/duckdb + <strong>hnswlib</strong> 등)</p>
  </li>
  <li>
    <p>다음은 종속성에 자주 포함되며 <strong>컴파일이 필요한 경우</strong> 가 있는 것들:</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">hnswlib</code>(C++11)</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">uvloop</code>, <code class="language-plaintext highlighter-rouge">httptools</code>, <code class="language-plaintext highlighter-rouge">watchfiles</code>(C/Rust 빌드 필요 가능)</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">orjson</code>(Rust) 또는 <code class="language-plaintext highlighter-rouge">ujson</code>(C)</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">scipy</code>, <code class="language-plaintext highlighter-rouge">pandas</code> (BLAS 연동/컴파일 이슈 → <strong>반드시 wheel</strong> 로)</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">pydantic</code>, <code class="language-plaintext highlighter-rouge">fastapi</code>, <code class="language-plaintext highlighter-rouge">starlette</code>, <code class="language-plaintext highlighter-rouge">uvicorn</code> 등은 보통 pure-Python이지만, <code class="language-plaintext highlighter-rouge">uvicorn[standard]</code>라면 위 네이티브 패키지를 추가로 끌어옵니다.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-오프라인-다운로드사전-준비-방법">2) 오프라인 다운로드(사전 준비) 방법</h3>

<p><strong>외부 인터넷 가능한 동일/유사 리눅스(x86_64, glibc) 머신</strong> 에서:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3.11 <span class="nt">-m</span> venv dl <span class="o">&amp;&amp;</span> <span class="nb">source </span>dl/bin/activate
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip wheel

<span class="c"># 목적지 폴더</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /tmp/wheelhouse

<span class="c"># 가장 쉬운 방법: 직접 종속성을 해석하게 맡김</span>
pip download <span class="nt">--dest</span> /tmp/wheelhouse open-webui chromadb

<span class="c"># 만약 아키텍처가 다르거나 강제로 휠만 받고 싶다면 (고급)</span>
pip download <span class="nt">--only-binary</span><span class="o">=</span>:all: <span class="se">\</span>
  <span class="nt">--platform</span> manylinux2014_x86_64 <span class="nt">--implementation</span> <span class="nb">cp</span> <span class="nt">--python-version</span> 311 <span class="se">\</span>
  <span class="nt">--dest</span> /tmp/wheelhouse open-webui chromadb
</code></pre></div></div>

<ul>
  <li>
    <p>오류가 나면, 메시지에 나온 패키지를 <strong>개별적으로 추가</strong> 해 다시 <code class="language-plaintext highlighter-rouge">pip download</code> 하세요(예: <code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">hnswlib</code>, <code class="language-plaintext highlighter-rouge">orjson</code> 등).</p>
  </li>
  <li>
    <p><strong>Rust toolchain 없이 설치하려면</strong> 반드시 <code class="language-plaintext highlighter-rouge">orjson</code>, <code class="language-plaintext highlighter-rouge">watchfiles</code> 등 <strong>미리 빌드된 wheel</strong> 을 확보해야 합니다.</p>
  </li>
</ul>

<p>서버로 복사 후, 오프라인 설치:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">--no-index</span> <span class="nt">--find-links</span> /path/to/wheelhouse open-webui chromadb
</code></pre></div></div>

<h3 id="3-chromachromadb-관련-주의점">3) Chroma(Chromadb) 관련 주의점</h3>

<ul>
  <li>
    <p>현재 에러의 원인인 <strong>sqlite3 ≥ 3.35</strong> 는 이미 A)에서 해결.</p>
  </li>
  <li>
    <p><strong>hnswlib</strong> 휠이 없으면 소스 빌드가 시도됩니다(오프라인/컴파일러 문제로 실패하기 쉬움). <strong>반드시 휠로 가져오세요.</strong></p>
  </li>
  <li>
    <p>성능을 위해 <code class="language-plaintext highlighter-rouge">numpy</code>도 <strong>휠</strong> 을 강력 추천합니다. (소스 빌드는 BLAS/LAPACK 등 추가 지뢰가 많음)</p>
  </li>
</ul>

<hr />

<h1 id="c-도구-체인컴파일러-등">C) 도구 체인(컴파일러 등)</h1>

<ul>
  <li>
    <p><strong>필수</strong> : <code class="language-plaintext highlighter-rouge">gcc</code>, <code class="language-plaintext highlighter-rouge">g++</code>, <code class="language-plaintext highlighter-rouge">make</code>, <code class="language-plaintext highlighter-rouge">tar</code>, <code class="language-plaintext highlighter-rouge">xz</code>, <code class="language-plaintext highlighter-rouge">patch</code>, <code class="language-plaintext highlighter-rouge">pkg-config</code></p>

    <ul>
      <li>대부분 RHEL 8에는 기본 제공되지만, 만약 사용자 PATH에 없다면 <strong>관리자에게 설치 요청</strong> 필요합니다(이 부분은 sudo/오프라인 환경에서 사용자 설치가 현실적으로 어렵습니다).</li>
    </ul>
  </li>
  <li>
    <p>선택(소스 빌드 많을 때 유용): <code class="language-plaintext highlighter-rouge">cmake</code>(일부 라이브러리), <code class="language-plaintext highlighter-rouge">ninja</code>(선택)</p>
  </li>
</ul>

<hr />

<h1 id="d-한-번에-끝내기-체크리스트">D) “한 번에 끝내기” 체크리스트</h1>

<ol>
  <li>
    <p>(외부 PC) 아래 소스/휠 다운로드</p>

    <ul>
      <li>
        <p>소스: <code class="language-plaintext highlighter-rouge">sqlite</code>, <code class="language-plaintext highlighter-rouge">openssl</code>, <code class="language-plaintext highlighter-rouge">zlib</code>, <code class="language-plaintext highlighter-rouge">bzip2</code>, <code class="language-plaintext highlighter-rouge">xz</code>, <code class="language-plaintext highlighter-rouge">readline</code>, <code class="language-plaintext highlighter-rouge">ncurses</code>, <code class="language-plaintext highlighter-rouge">libffi</code>, <code class="language-plaintext highlighter-rouge">expat</code>, <code class="language-plaintext highlighter-rouge">Python-3.11.12.tgz</code></p>
      </li>
      <li>
        <p>휠: <code class="language-plaintext highlighter-rouge">open-webui</code>, <code class="language-plaintext highlighter-rouge">chromadb</code>, <code class="language-plaintext highlighter-rouge">hnswlib</code>, <code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">uvicorn</code>, <code class="language-plaintext highlighter-rouge">fastapi</code>, <code class="language-plaintext highlighter-rouge">pydantic</code>, <code class="language-plaintext highlighter-rouge">starlette</code>, <code class="language-plaintext highlighter-rouge">watchfiles</code>, <code class="language-plaintext highlighter-rouge">orjson</code>(또는 <code class="language-plaintext highlighter-rouge">ujson</code>), 기타 자동으로 끌려오는 것들 전부</p>
      </li>
    </ul>
  </li>
  <li>
    <p>(서버) A 순서대로 <strong>네이티브 라이브러리</strong> 를 <code class="language-plaintext highlighter-rouge">$HOME/opt/...</code>에 설치</p>
  </li>
  <li>
    <p>(서버) 환경변수로 include/lib/rpath 셋업 후 <strong>Python 빌드</strong></p>
  </li>
  <li>
    <p>(서버) 새 <strong>venv 생성</strong> → <code class="language-plaintext highlighter-rouge">pip install --no-index --find-links …</code>로 <strong>휠</strong> 설치</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">python -c "import sqlite3; print(sqlite3.sqlite_version)"</code>가 3.35+인지 확인</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">open-webui serve</code> 실행 테스트</p>
  </li>
</ol>

<hr />

<p>필요하시면, 위 라이브러리들 <strong>오프라인 빌드 자동화 스크립트(하나의 bash 파일)</strong>와, <strong>pip wheelhouse 만들기용 명령어 세트</strong> 를 사용자 환경에 맞춰 뽑아드릴게요. 어떤 버전 조합으로 가실지 알려주시면 바로 만들어 드립니다.</p>

<p class="chat--user">

으악 너무 많아. 저것들이 다 꼭 필요한거야? 난 오류만 안나면 돼

</p>

<p>확실히 많았죠 😂 “오류만 안 나게”가 목표라면 <strong>딱 하나만</strong> 해결하면 됩니다:</p>

<h2 id="핵심만-sqlite만-새로-깔고-python을-그걸로-다시-빌드">핵심만: SQLite만 새로 깔고, Python을 그걸로 다시 빌드</h2>

<p>Chroma 에러의 <strong>직접 원인</strong> 은 <code class="language-plaintext highlighter-rouge">sqlite3 &lt; 3.35</code>뿐이에요.<br />
즉, <strong>다른 라이브러리들을 전혀 건드리지 않아도</strong> 됩니다.</p>

<h3 id="0-변수폴더">0) 변수/폴더</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/src <span class="nv">$HOME</span>/opt
<span class="nb">export </span><span class="nv">SQLITE_VER</span><span class="o">=</span>3.45.4              <span class="c"># 3.35.0 이상이면 OK</span>
<span class="nb">export </span><span class="nv">PY_VER</span><span class="o">=</span>3.11.12

<span class="nb">export </span><span class="nv">SQLITE_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/sqlite-</span><span class="nv">$SQLITE_VER</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">PY_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/python-</span><span class="nv">$PY_VER</span><span class="s2">"</span>
</code></pre></div></div>

<h3 id="1-오프라인에서-가져온-소스-업로드">1) (오프라인에서 가져온) 소스 업로드</h3>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sqlite-autoconf-&lt;NNNNNNN&gt;.tar.gz</code> (예: 3.45.4 → 3450400)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Python-3.11.12.tgz</code><br />
이 두 개만 있으면 충분합니다.</p>
  </li>
</ul>

<h3 id="2-sqlite만-사용자-경로에-설치">2) SQLite만 사용자 경로에 설치</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span>/src
<span class="nb">tar </span>xf sqlite-autoconf-3450400.tar.gz
<span class="nb">cd </span>sqlite-autoconf-3450400

<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> ./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>

<span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/bin/sqlite3"</span> <span class="nt">--version</span>    <span class="c"># 3.35.0 이상 확인</span>
</code></pre></div></div>

<h3 id="3-python을-그-sqlite로만-링크해서-재빌드">3) Python을 “그 SQLite”로만 링크해서 재빌드</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span>/src
<span class="nb">tar </span>xf Python-3.11.12.tgz
<span class="nb">cd </span>Python-3.11.12

<span class="c"># 컴파일러가 새 sqlite를 보게 경로 지정 + rpath 심기</span>
<span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">"-I</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/include"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib -Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>

./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">"</span> <span class="nt">--with-ensurepip</span><span class="o">=</span><span class="nb">install
</span>make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="4-경로-적용--버전-확인">4) 경로 적용 + 버전 확인</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>

python3 <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>
<span class="c"># &gt;&gt;&gt; 3.35.0 이상 나오면 끝!</span>
</code></pre></div></div>

<h3 id="5-venv-새로-만들기-중요">5) venv 새로 만들기 (중요)</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> venv <span class="nv">$HOME</span>/venvs/openwebui
<span class="nb">source</span> <span class="nv">$HOME</span>/venvs/openwebui/bin/activate
python <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>  <span class="c"># 다시 3.35+ 확인</span>
</code></pre></div></div>

<p>이제 <strong>같은 에러 없이</strong> Open WebUI / Chroma 돌릴 수 있습니다.</p>

<hr />

<h2 id="혹시-생길-수-있는-딱-두-가지-추가-오류만-메모">혹시 생길 수 있는 “딱 두 가지” 추가 오류만 메모</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ssl</code> 모듈 없다는 에러 → <strong>온라인 pip 필요할 때만</strong> 발생. 지금은 오프라인이라면 무시해도 OK.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">readline</code> 히스토리 안 먹음 → 기능상 불편이지만 <strong>치명적 아님</strong>. 필요할 때만 나중에 해결.</p>
  </li>
</ul>

<blockquote>
  <p>요약: <strong>지금은 SQLite만</strong> 해결하세요. 나머지는 문제 생기면 그때 최소만 붙이면 돼요.</p>
</blockquote>

<p>원하면 위 절차를 <strong>복붙용 한 파일 스크립트</strong> 로 묶어 드릴게요.</p>

<p class="chat--user">

sqlite Precomiled Binary가 있는데 그냥 이거 받아서 써도 되나?

</p>

<p>네, 전제 조건만 맞으면 <strong>Precompiled Binary</strong>(미리 컴파일된 sqlite3) 써도 됩니다.<br />
다만 Python은 실행 시 시스템 PATH에 있는 <code class="language-plaintext highlighter-rouge">sqlite3</code> CLI가 아니라, <strong>빌드 시점에 링크된 libsqlite3.so</strong> 를 씁니다.</p>

<p>즉, 단순히 sqlite3 실행파일만 받아서 두는 건 의미 없고, <strong>라이브러리(.so)와 헤더(.h)</strong> 까지 있어야 합니다.</p>

<hr />

<h2 id="1-필요한-구성-요소">1) 필요한 구성 요소</h2>

<p>SQLite precompiled package 안에 보통 다음이 있어야 합니다:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sqlite3</code> 실행파일 (CLI)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">libsqlite3.so</code> (또는 .a)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sqlite3.h</code> 등 개발용 헤더 파일</p>
  </li>
</ul>

<p>만약 제공된 게 <strong>CLI 실행파일만</strong> 이라면 → Python 재빌드에는 못 씁니다.</p>

<hr />

<h2 id="2-쓸-수-있는-경우">2) 쓸 수 있는 경우</h2>

<ul>
  <li>
    <p>precompiled bundle이 <code class="language-plaintext highlighter-rouge">include/</code> 와 <code class="language-plaintext highlighter-rouge">lib/</code> 디렉터리를 함께 제공</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">libsqlite3.so</code>가 <strong>3.35.0 이상</strong></p>
  </li>
  <li>
    <p>해당 빌드가 <strong>RHEL 8.x glibc 호환</strong></p>
  </li>
</ul>

<p>설치 예:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/opt/sqlite-prebuilt
<span class="nb">tar </span>xf sqlite-precompiled.tar.gz <span class="nt">-C</span> <span class="nv">$HOME</span>/opt/sqlite-prebuilt

<span class="nb">export </span><span class="nv">SQLITE_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/sqlite-prebuilt"</span>
<span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">"-I</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/include"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib -Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>

<span class="c"># 이후 Python 빌드</span>
<span class="nb">cd </span>Python-3.11.12
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/python-3.11.12"</span> <span class="nt">--with-ensurepip</span><span class="o">=</span><span class="nb">install
</span>make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>
</code></pre></div></div>

<hr />

<h2 id="3-주의할-점">3) 주의할 점</h2>

<ul>
  <li>
    <p>precompiled binary의 <code class="language-plaintext highlighter-rouge">.so</code> 파일이 <strong>정적 경로</strong>(<code class="language-plaintext highlighter-rouge">/usr/lib</code> 등)에 깔린 게 아니므로,<br />
실행 시 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 또는 rpath로 경로를 알려줘야 합니다.</p>
  </li>
  <li>
    <p>glibc 버전 호환성이 안 맞으면 <code class="language-plaintext highlighter-rouge">symbol not found</code> 같은 런타임 오류가 날 수 있습니다.</p>
  </li>
  <li>
    <p>Python 빌드 시 <code class="language-plaintext highlighter-rouge">_sqlite3</code> 모듈이 안 잡히면, 헤더(<code class="language-plaintext highlighter-rouge">sqlite3.h</code>) 경로가 CPPFLAGS에 잡혀 있는지 확인해야 합니다.</p>
  </li>
</ul>

<hr />

<p>📌 결론:</p>

<ul>
  <li>
    <p><strong>라이브러리+헤더 포함된 패키지</strong> 면 문제 없이 사용 가능</p>
  </li>
  <li>
    <p>CLI만 있는 패키지는 Chroma 문제 해결 불가</p>
  </li>
  <li>
    <p>Python 빌드시 새 sqlite를 명시적으로 링크해야만 적용됨</p>
  </li>
</ul>

<hr />

<p>원하시면, 제가 <strong>precompiled binary가 쓸 수 있는지 체크하는 명령어 세트</strong> 를 드릴 수 있습니다.<br />
그걸로 지금 가지고 있는 패키지가 Python 빌드에 바로 쓸 수 있는지 바로 확인할 수 있어요.<br />
그거 드릴까요?</p>

<p class="chat--user">

응 so가 없네

</p>

<p>그럼 그 precompiled binary는 <strong>Python 빌드에는 못 씁니다</strong>.</p>

<p>Python이 사용하는 <code class="language-plaintext highlighter-rouge">_sqlite3</code> 모듈은</p>

<ul>
  <li>
    <p><strong>sqlite3.h</strong>(헤더 파일)</p>
  </li>
  <li>
    <p><strong>libsqlite3.so</strong>(공유 라이브러리)</p>
  </li>
</ul>

<p>이 두 가지가 <strong>빌드 시점에 필요</strong> 합니다.<br />
CLI 실행파일(<code class="language-plaintext highlighter-rouge">sqlite3</code>)만으로는 전혀 적용이 안 돼요.<br />
그래서 결국 SQLite 소스를 받아서 직접 빌드해야 합니다.</p>

<hr />

<p>📌 <strong>정리</strong></p>

<ul>
  <li>
    <p>지금 상황(so 없음) → Python 재빌드 시 구버전 시스템 라이브러리를 그대로 링크 → Chroma 에러 재발</p>
  </li>
  <li>
    <p>해결 방법 → SQLite 소스 tar.gz 받아서 <code class="language-plaintext highlighter-rouge">$HOME/opt/sqlite-&lt;ver&gt;</code>에 설치 후, Python 빌드할 때 그 경로를 연결</p>
  </li>
</ul>

<hr />

<p>원하면 제가 <strong>딱 SQLite만</strong> 빌드하고 Python에 붙이는 최소 스크립트**를 만들어서<br />
그대로 복붙해서 쓰면 되게 해드릴까요?<br />
그렇게 하면 다른 의존성 건드릴 필요 없이 한 번에 끝납니다.</p>

<p class="chat--user">

sqlite 빌드할 때 내가 설치한 GCC 사용하고 싶어.

</p>

<p>좋지! <strong>sudo 없이, 내가 설치한 GCC로만</strong> SQLite를 빌드해서 <code class="language-plaintext highlighter-rouge">.so</code>까지 만들고, 그걸로 파이썬을 다시 빌드하는 최소 절차를 딱 정리해줄게. (RHEL 8.x, 오프라인 가정)</p>

<hr />

<h1 id="0-전제-내가-설치한-gcc-위치">0) 전제: 내가 설치한 GCC 위치</h1>

<p>아래처럼 경로만 너 환경에 맞게 바꿔줘.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 내가 설치한 GCC 루트(예: $HOME/opt/gcc-12.3.0)</span>
<span class="nb">export </span><span class="nv">TOOLCHAIN_ROOT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/gcc-12.3.0"</span>

<span class="c"># PATH와 런타임 라이브러리 경로(중요)</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/lib64:</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>

<span class="c"># 확인</span>
which gcc
gcc <span class="nt">--version</span>
</code></pre></div></div>

<blockquote>
  <p>필요하면 binutils까지 같이 쓴다는 의미로 <code class="language-plaintext highlighter-rouge">AR/RANLIB/LD</code>도 지정 가능:<br />
 <code class="language-plaintext highlighter-rouge">export AR="$TOOLCHAIN_ROOT/bin/ar"; export RANLIB="$TOOLCHAIN_ROOT/bin/ranlib"</code></p>
</blockquote>

<hr />

<h1 id="1-sqlite를-내-gcc로-빌드공유-라이브러리-so-생성">1) SQLite를 “내 GCC”로 빌드(+공유 라이브러리 .so 생성)</h1>

<p>오프라인으로 가져온 <code class="language-plaintext highlighter-rouge">sqlite-autoconf-&lt;NNNNNNN&gt;.tar.gz</code> 기준.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설치 위치(원하는 곳으로)</span>
<span class="nb">export </span><span class="nv">SQLITE_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/sqlite-3.45.4"</span>

<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/src"</span> <span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span>
<span class="nb">cd</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/src"</span>
<span class="nb">tar </span>xf sqlite-autoconf-3450400.tar.gz
<span class="nb">cd </span>sqlite-autoconf-3450400

<span class="c"># ★ 핵심: CC를 내 GCC로 지정, -fPIC, rpath까지 준비</span>
<span class="nb">export </span><span class="nv">CC</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/bin/gcc"</span>
<span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC </span><span class="se">\</span><span class="s2">
-DSQLITE_ENABLE_FTS5 </span><span class="se">\</span><span class="s2">
-DSQLITE_ENABLE_JSON1 </span><span class="se">\</span><span class="s2">
-DSQLITE_ENABLE_COLUMN_METADATA </span><span class="se">\</span><span class="s2">
-DSQLITE_ENABLE_RTREE </span><span class="se">\</span><span class="s2">
-DSQLITE_THREADSAFE=1"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>

<span class="c"># configure → build → install</span>
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span> <span class="nt">--enable-shared</span> <span class="nt">--disable-static</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>

<span class="c"># 검증</span>
<span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/bin/sqlite3"</span> <span class="nt">--version</span>            <span class="c"># 3.35.0 이상</span>
<span class="nb">ls</span> <span class="nt">-l</span> <span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib/libsqlite3.so"</span>          <span class="c"># .so 존재 확인</span>
ldd <span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib/libsqlite3.so"</span> | <span class="nb">head</span>     <span class="c"># 내 GCC의 libgcc_s 등 링크 확인</span>
</code></pre></div></div>

<blockquote>
  <p>TIP</p>

  <ul>
    <li>
      <p><code class="language-plaintext highlighter-rouge">--enable-shared</code>로 <code class="language-plaintext highlighter-rouge">.so</code> 생성 확실히.</p>
    </li>
    <li>
      <p>rpath는 나중에 파이썬이 이 <code class="language-plaintext highlighter-rouge">.so</code>를 찾을 수 있게 하는 안전장치.</p>
    </li>
    <li>
      <p>만약 <code class="language-plaintext highlighter-rouge">ldd</code>에서 이상한 시스템 lib로 엮이면 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>가 제대로 잡혔는지 다시 확인.</p>
    </li>
  </ul>

</blockquote>

<hr />

<h1 id="2-파이썬을-그-sqlite-so헤더로-링크해서-재빌드">2) 파이썬을 “그 SQLite .so/헤더”로 링크해서 재빌드</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 파이썬 설치 경로</span>
<span class="nb">export </span><span class="nv">PY_PREFIX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/opt/python-3.11.12"</span>

<span class="c"># 컴파일/링크에 SQLite 경로 반영 + 런타임 rpath</span>
<span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">"-I</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/include"</span>
<span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib -Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib:</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/lib64:</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/lib:</span><span class="nv">$LD_LIBRARY_PATH</span><span class="s2">"</span>

<span class="c"># (옵션) 파이썬도 내 GCC로</span>
<span class="nb">export </span><span class="nv">CC</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLCHAIN_ROOT</span><span class="s2">/bin/gcc"</span>

<span class="nb">cd</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/src"</span>
<span class="nb">tar </span>xf Python-3.11.12.tgz
<span class="nb">cd </span>Python-3.11.12

./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">"</span> <span class="nt">--with-ensurepip</span><span class="o">=</span><span class="nb">install
</span>make <span class="nt">-n</span> <span class="o">&gt;</span> /dev/null 2&gt;&amp;1  <span class="c"># (캐시 생성용 살짝 돌리기; 생략 가능)</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>

<span class="c"># PATH 적용 및 확인</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY_PREFIX</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>
python3 <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>
<span class="c"># ==&gt; 3.35.0 이상 나오면 성공!</span>
</code></pre></div></div>

<blockquote>
  <p>만약 <code class="language-plaintext highlighter-rouge">_sqlite3</code>가 빠졌다는 메시지가 나오면:</p>

  <ul>
    <li>
      <p><code class="language-plaintext highlighter-rouge">CPPFLAGS/LDFLAGS/LD_LIBRARY_PATH</code>가 맞는지 확인</p>
    </li>
    <li>
      <p>필요 시 <code class="language-plaintext highlighter-rouge">Modules/Setup.local</code>에 아래 한 줄 추가 후 <code class="language-plaintext highlighter-rouge">make install</code> 다시 실행</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
    
_sqlite3 _sqlite/module.c -I$SQLITE_PREFIX/include -L$SQLITE_PREFIX/lib -lsqlite3
    
</code></pre></div>      </div>
    </li>
  </ul>

</blockquote>

<hr />

<h1 id="3-venv-새로-만들기-중요">3) venv 새로 만들기 (중요)</h1>

<p>기존 venv는 구버전 파이썬 기준이므로 새로 생성해야 해.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> venv <span class="nv">$HOME</span>/venvs/openwebui
<span class="nb">source</span> <span class="nv">$HOME</span>/venvs/openwebui/bin/activate
python <span class="nt">-c</span> <span class="s2">"import sqlite3; print(sqlite3.sqlite_version)"</span>  <span class="c"># 3.35+ 재확인</span>
</code></pre></div></div>

<hr />

<h2 id="자주-묻는-포인트-진짜-핵심만">자주 묻는 포인트 (진짜 핵심만)</h2>

<ul>
  <li>
    <p><strong>Q. 그냥 sqlite3 실행파일만 있으면 안 돼?</strong><br />
A. 안 돼. 파이썬 빌드에는 <code class="language-plaintext highlighter-rouge">libsqlite3.so</code> + <code class="language-plaintext highlighter-rouge">sqlite3.h</code>가 필요.</p>
  </li>
  <li>
    <p><strong>Q. 꼭 내 GCC여야 하나?</strong><br />
A. 네. 네이티브 툴체인 혼용하면 런타임에 <code class="language-plaintext highlighter-rouge">symbol not found</code> 날 수 있음. PATH/LD_LIBRARY_PATH를 내 GCC로 먼저 잡아.</p>
  </li>
  <li>
    <p><strong>Q. rpath 꼭 넣어야 해?</strong><br />
A. 강추. 그러면 이후에 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 깜박해도 파이썬이 <code class="language-plaintext highlighter-rouge">libsqlite3.so</code>를 바로 찾음.</p>
  </li>
</ul>

<hr />

<p>필요하면 위 과정을 <strong>복붙만 하면 되는 단일 bash 스크립트</strong> 로 만들어 줄게. 경로랑 버전만 바꾸면 바로 돌아가게!</p>

<p class="chat--user">

-W1,-rpath 이건 뭐하는 옵션이야?

</p>

<p>아마 제가 적은 건 <code class="language-plaintext highlighter-rouge">-Wl,-rpath</code> 인데, 그건 타이핑이 조금 비슷해서 헷갈린 걸 거예요.<br />
(<code class="language-plaintext highlighter-rouge">-W1</code>은 의미 없고, <code class="language-plaintext highlighter-rouge">-Wl</code>이 맞습니다. 여기서 소문자 L은 “linker”의 L)</p>

<hr />

<h2 id="-wl-rpath경로-의미"><code class="language-plaintext highlighter-rouge">-Wl,-rpath,&lt;경로&gt;</code> 의미</h2>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">-Wl,</code></strong></p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">gcc</code>나 <code class="language-plaintext highlighter-rouge">g++</code> 같은 컴파일 드라이버에 <strong>링커 옵션을 그대로 전달</strong> 하라는 뜻입니다.</p>
      </li>
      <li>
        <p>즉, <code class="language-plaintext highlighter-rouge">-Wl,옵션</code> → “이 옵션은 링커(ld)에게 주는 거야”라는 의미.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">-rpath,&lt;경로&gt;</code></strong></p>

    <ul>
      <li>
        <p><strong>런타임 라이브러리 검색 경로</strong> 를 바이너리에 <strong>직접 박아 넣음</strong>.</p>
      </li>
      <li>
        <p>실행 파일이 만들어질 때 ELF 헤더의 <code class="language-plaintext highlighter-rouge">RPATH</code>(또는 <code class="language-plaintext highlighter-rouge">RUNPATH</code>)에 <code class="language-plaintext highlighter-rouge">&lt;경로&gt;</code>를 기록합니다.</p>
      </li>
      <li>
        <p>그래서 실행할 때 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>를 따로 안 잡아도 해당 경로에서 <code class="language-plaintext highlighter-rouge">.so</code>를 자동으로 찾습니다.</p>
      </li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="예시">예시</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc main.c <span class="nt">-L</span><span class="nv">$HOME</span>/opt/sqlite/lib <span class="nt">-lsqlite3</span> <span class="se">\</span>
    <span class="nt">-Wl</span>,-rpath,<span class="nv">$HOME</span>/opt/sqlite/lib
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-L…</code> : 빌드할 때 라이브러리 검색 경로</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-Wl,-rpath,…</code> : 실행할 때도 이 경로를 기억해서 libsqlite3.so 찾음</p>
  </li>
</ul>

<hr />

<h3 id="왜-pythonsqlite-빌드에-쓰나">왜 Python/SQLite 빌드에 쓰나?</h3>

<ul>
  <li>
    <p>홈 디렉토리 같은 <strong>비표준 경로</strong> 에 설치한 <code class="language-plaintext highlighter-rouge">.so</code>는 기본 런타임 경로에 없어요.</p>
  </li>
  <li>
    <p>매번 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH=$HOME/opt/sqlite/lib</code> 설정하는 건 번거롭죠.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-Wl,-rpath</code>를 빌드 시 넣어두면 <strong>그 파이썬 실행 파일이 항상 그 경로에서 먼저 .so를 찾게 됩니다</strong>.</p>
  </li>
</ul>

<hr />

<p>원하시면 제가 <strong><code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 없이도 동작하게 rpath 넣은 Python+SQLite 빌드 스크립트</strong>를 바로 만들어드릴게요.<br />
그럼 환경변수 깜빡해도 안전합니다.</p>

<p class="chat--user">

근데 sqlite할 때도 LDFLAGS를 넣어줘야해?

</p>

<p>SQLite 빌드할 때는 <strong>상황에 따라 다릅니다</strong> 👍</p>

<hr />

<h2 id="1-기본적으로는-ldflags-없어도-빌드됨">1. 기본적으로는 LDFLAGS 없어도 빌드됨</h2>

<ul>
  <li>
    <p>SQLite 자체는 외부 라이브러리 의존성이 거의 없어요.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">./configure --prefix=…</code>만으로도 <code class="language-plaintext highlighter-rouge">libsqlite3.so</code> 잘 만들어집니다.</p>
  </li>
  <li>
    <p>그래서 <strong>순수 SQLite 빌드</strong> 라면 <code class="language-plaintext highlighter-rouge">LDFLAGS</code>를 안 줘도 무방합니다.</p>
  </li>
</ul>

<hr />

<h2 id="2-그런데-내가-원하는-rpath를-박고-싶다면-ldflags-필요">2. 그런데 내가 원하는 rpath를 박고 싶다면 LDFLAGS 필요</h2>

<ul>
  <li>
    <p>SQLite를 설치한 <strong>비표준 경로</strong> 를 Python 빌드 시 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 없이 사용하고 싶으면,<br />
SQLite를 빌드할 때도 <code class="language-plaintext highlighter-rouge">.so</code> 안에 rpath를 넣을 수 있습니다.</p>
  </li>
  <li>
    <p>예:</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
</code></pre></div></div>

<p>이렇게 하면 SQLite CLI(<code class="language-plaintext highlighter-rouge">sqlite3</code>)나 SQLite를 링크한 프로그램이 실행될 때<br />
<code class="language-plaintext highlighter-rouge">$SQLITE_PREFIX/lib</code>를 자동으로 검색합니다.</p>

<hr />

<h2 id="3-python-빌드에서는-ldflags-필수">3. Python 빌드에서는 LDFLAGS 필수</h2>

<ul>
  <li>Python이 <code class="language-plaintext highlighter-rouge">_sqlite3</code> 모듈을 만들 때 <code class="language-plaintext highlighter-rouge">libsqlite3.so</code>를 어디서 찾을지 알아야 해서,<br />
Python 빌드할 때는 반드시
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib -Wl,-rpath,</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/lib"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>처럼 넣어주는 게 안전합니다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-L…</code> → 컴파일/링크 시 검색 경로</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-Wl,-rpath,…</code> → 런타임 검색 경로</p>
  </li>
</ul>

<hr />

<p>✅ <strong>정리</strong></p>

<ul>
  <li>
    <p><strong>SQLite 빌드:</strong> LDFLAGS 없이도 가능. rpath를 넣고 싶으면 추가.</p>
  </li>
  <li>
    <p><strong>Python 빌드:</strong> LDFLAGS 필수. 최소한 <code class="language-plaintext highlighter-rouge">-L&lt;sqlite lib&gt;</code> + <code class="language-plaintext highlighter-rouge">-Wl,-rpath,&lt;sqlite lib&gt;</code>는 꼭 넣어야 안전.</p>
  </li>
</ul>

<hr />

<p>원하면 제가 <strong>SQLite 빌드 때 rpath 없이, Python 빌드 때만 rpath 넣는 최소 설치 스크립트</strong> 를 바로 짜 드릴 수 있습니다.<br />
그렇게 하면 불필요한 옵션은 안 쓰면서도 Python에서만 경로를 기억하게 할 수 있어요.</p>

<p class="chat--user">

그런데 왜 이렇게 설정할 것이 많아? configure의 default로 어느정도 reasonable한 설정이 들어가있는거 아니야?

</p>

<p>맞아요 — <code class="language-plaintext highlighter-rouge">./configure</code>가 이미 꽤 <strong>reasonable한 기본값</strong> 을 넣어주긴 합니다.</p>

<p>그런데 우리가 지금 설정을 많이 건드리는 이유는 <strong>기본값이 "시스템에 이미 깔린 것" 기준</strong> 이기 때문이에요.<br />
RHEL 8처럼 오래된 OS + sudo 불가 환경에서는 그 기본값이 <strong>원하는 최신 라이브러리를 전혀 안 봅니다</strong>.</p>

<hr />

<h2 id="1-configure의-기본-동작">1. <code class="language-plaintext highlighter-rouge">configure</code>의 기본 동작</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">./configure</code>는 <code class="language-plaintext highlighter-rouge">PATH</code>와 표준 라이브러리 경로(<code class="language-plaintext highlighter-rouge">/usr/include</code>, <code class="language-plaintext highlighter-rouge">/usr/lib64</code> 등)에서 헤더와 .so를 찾습니다.</p>
  </li>
  <li>
    <p>최신 라이브러리를 <strong>비표준 경로</strong>(<code class="language-plaintext highlighter-rouge">$HOME/opt/...</code>)에 설치해도, 특별히 알려주지 않으면 그냥 무시하고 시스템 기본 구버전을 씁니다.</p>
  </li>
  <li>
    <p>예: Python이 <code class="language-plaintext highlighter-rouge">_sqlite3</code> 모듈을 빌드할 때 <code class="language-plaintext highlighter-rouge">/usr/include/sqlite3.h</code> + <code class="language-plaintext highlighter-rouge">/usr/lib64/libsqlite3.so</code>를 찾아서 링크 → 결과적으로 3.26.0.</p>
  </li>
</ul>

<hr />

<h2 id="2-왜-우리가-cppflagsldflags를-주나">2. 왜 우리가 CPPFLAGS/LDFLAGS를 주나?</h2>

<ul>
  <li>
    <p>"야, 헤더는 여기 있다!" → <code class="language-plaintext highlighter-rouge">CPPFLAGS="-I$SQLITE_PREFIX/include"</code></p>
  </li>
  <li>
    <p>"라이브러리는 여기 있다!" → <code class="language-plaintext highlighter-rouge">LDFLAGS="-L$SQLITE_PREFIX/lib"</code></p>
  </li>
  <li>
    <p>"실행할 때도 여기서 찾아라!" → <code class="language-plaintext highlighter-rouge">-Wl,-rpath,$SQLITE_PREFIX/lib</code></p>
  </li>
  <li>
    <p>이걸 안 하면, 빌드 시 <strong>컴파일러는 최신 헤더를 못 보고</strong> ,<br />
실행 시 <strong>런타임 로더는 최신 .so를 못 찾습니다</strong>.</p>
  </li>
</ul>

<hr />

<h2 id="3-rpath까지-넣는-이유">3. rpath까지 넣는 이유</h2>

<ul>
  <li>
    <p>기본적으로 실행 시 <code class="language-plaintext highlighter-rouge">.so</code>는 <code class="language-plaintext highlighter-rouge">/lib</code>, <code class="language-plaintext highlighter-rouge">/usr/lib</code>, <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>에서 찾습니다.</p>
  </li>
  <li>
    <p>홈 디렉토리에 깔린 <code class="language-plaintext highlighter-rouge">.so</code>는 기본 검색 경로에 없어요.</p>
  </li>
  <li>
    <p>매번 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>를 세팅하지 않으려면 rpath로 박아두는 게 편리.</p>
  </li>
</ul>

<hr />

<h2 id="4-요약-비유">4. 요약 비유</h2>

<p>기본 <code class="language-plaintext highlighter-rouge">configure</code>는 <strong>"부엌(시스템 기본 경로)에 있는 재료만"</strong> 씁니다.<br />
우리가 한 건 <strong>"냉장고(홈 디렉토리)에 있는 최신 재료도 써!"</strong> 하고 경로를 알려주는 거예요.</p>

<hr />

<p>원하면 제가 <strong>이 경로 설정을 최소화해서, SQLite 최신판만 쓰게 하는 configure 예제</strong> 를 아주 간단히 정리해 드릴까요?<br />
그러면 지금처럼 CPPFLAGS/LDFLAGS를 여러 줄 쓰지 않고도 깔끔하게 됩니다.</p>

<p class="chat--user">

아니 rpath나 라이브러리는 다 이해해 export CFLAGS="-O2 -fPIC \ -DSQLITE_ENABLE_FTS5 \ -DSQLITE_ENABLE_JSON1 \ -DSQLITE_ENABLE_COLUMN_METADATA \ -DSQLITE_ENABLE_RTREE \ -DSQLITE_THREADSAFE=1" 이거는 좀 귀찮아서 안넣었어 근데

</p>

<p>괜찮아—저 플래그들(<strong>FTS5/JSON1/RTREE/COLUMN_METADATA/THREADSAFE</strong>)은 “기능 토글”일 뿐이고, <strong>Chroma + Open WebUI가 돌아가는데 필수는 아니야.</strong><br />
현재 목표(에러만 안 나게)는 <strong>버전 ≥ 3.35.0</strong> 이 핵심이고, 빌드에선 <strong><code class="language-plaintext highlighter-rouge">-fPIC</code></strong> 정도만 챙기면 충분합니다.</p>

<h2 id="결론-먼저">결론 먼저</h2>

<ul>
  <li>
    <p><strong>지금 당장은</strong> <code class="language-plaintext highlighter-rouge">CFLAGS="-O2 -fPIC"</code> 만 줘도 OK.</p>
  </li>
  <li>
    <p>추가 기능이 필요할 때만 그때 다시 켜면 됩니다. (다시 빌드해도 Python 쪽 큰 수정 필요 없음)</p>
  </li>
</ul>

<h2 id="각-옵션이-실제로-뭘-켜는지-필요할-때만">각 옵션이 실제로 뭘 켜는지 (필요할 때만!)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQLITE_ENABLE_FTS5</code> : 풀텍스트 검색(FTS5) 엔진. 대부분의 앱에 <strong>필수 아님</strong>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQLITE_ENABLE_JSON1</code> : JSON 함수(<code class="language-plaintext highlighter-rouge">json_extract</code> 등). 쿼리에서 JSON 다룰 때만 필요.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQLITE_ENABLE_RTREE</code> : R-Tree 인덱스(공간/범위). 특수한 경우에만.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQLITE_ENABLE_COLUMN_METADATA</code> : 컬럼 메타데이터 API. 일반 사용엔 거의 불필요.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQLITE_THREADSAFE=1</code> : 스레드 세이프. <strong>기본값이 1</strong> 이므로 굳이 지정 안 해도 됨.</p>
  </li>
</ul>

<h2 id="최소-안전-빌드-예시">“최소 안전” 빌드 예시</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 최소만: 성능 + 공유라이브러리 생성</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> <span class="se">\</span>
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span> <span class="nt">--enable-shared</span> <span class="nt">--disable-static</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="나중에-기능이-필요해지면선택">나중에 기능이 필요해지면(선택)</h2>

<p>귀찮은 매크로 대신 <strong>configure 플래그</strong> 로 켜도 됩니다:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> <span class="se">\</span>
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span> <span class="nt">--enable-shared</span> <span class="nt">--disable-static</span> <span class="se">\</span>
  <span class="nt">--enable-fts5</span> <span class="nt">--enable-json1</span> <span class="nt">--enable-rtree</span>
make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
</code></pre></div></div>

<p>(= 내부적으로 위 매크로들을 정의해줍니다)</p>

<h2 id="현재-빌드에-뭐가-켜졌는지-확인">현재 빌드에 뭐가 켜졌는지 확인</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$SQLITE_PREFIX</span>/bin/sqlite3 <span class="nt">-cmd</span> <span class="s2">"PRAGMA compile_options;"</span> <span class="s2">":memory:"</span> <span class="s2">".quit"</span>
<span class="c"># 또는</span>
<span class="nv">$SQLITE_PREFIX</span>/bin/sqlite3 <span class="nt">-line</span> <span class="s2">":memory:"</span> <span class="s2">"PRAGMA compile_options;"</span>
</code></pre></div></div>

<p>여기에 <code class="language-plaintext highlighter-rouge">ENABLE_FTS5</code>, <code class="language-plaintext highlighter-rouge">ENABLE_JSON1</code> 같은 항목이 뜨면 켜진 것.</p>

<hr />

<h3 id="요약">요약</h3>

<ul>
  <li>
    <p><strong>지금은 CFLAGS 최소(-O2 -fPIC)만</strong> 넣고 진행해도 무방.</p>
  </li>
  <li>
    <p>Chroma 에러는 “버전” 이슈였고, 부가 기능 플래그는 필수 아님.</p>
  </li>
  <li>
    <p>나중에 필요해지면 <code class="language-plaintext highlighter-rouge">--enable-fts5/json1/rtree</code>로 다시 빌드하면 끝.</p>
  </li>
</ul>

<p class="chat--user">

no such module: fts5 enable 을 해야하나본

</p>

<p>맞아요—그 메시지는 <strong>FTS5가 꺼져 있어서</strong> 나는 거예요.<br />
이미 한 번 빌드하셨다면, <strong>SQLite만 다시 컴파일</strong> 해서 <code class="language-plaintext highlighter-rouge">libsqlite3.so</code>를 교체하면 됩니다. (Python은 다시 안 빌려도 됨—같은 경로의 <code class="language-plaintext highlighter-rouge">.so</code>를 런타임에 쓰니까요)</p>

<h2 id="빠른-해결-컴파일에-포함시키는-방법">빠른 해결 (컴파일에 포함시키는 방법)</h2>

<p>아래처럼 <code class="language-plaintext highlighter-rouge">--enable-fts5</code>만 추가해서 <strong>다시 빌드·설치</strong> 하세요.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 전제: 이전과 같은 PREFIX를 사용 (예: $SQLITE_PREFIX)</span>
<span class="nb">cd</span> <span class="nv">$HOME</span>/src/sqlite-autoconf-3450400   <span class="c"># 소스 디렉터리로 이동</span>

<span class="c"># (내 GCC를 쓰는 중이라면) CC/LD_LIBRARY_PATH를 이전과 동일하게 잡아두세요.</span>
<span class="c"># export CC="$TOOLCHAIN_ROOT/bin/gcc"</span>
<span class="c"># export LD_LIBRARY_PATH="$TOOLCHAIN_ROOT/lib64:$LD_LIBRARY_PATH"</span>

<span class="c"># 최소 옵션 + FTS5만 켜기</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> <span class="se">\</span>
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">--enable-shared</span> <span class="nt">--disable-static</span> <span class="se">\</span>
  <span class="nt">--enable-fts5</span>

make <span class="nt">-j</span><span class="s2">"</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span><span class="s2">"</span>
make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="켜졌는지-확인">켜졌는지 확인</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/bin/sqlite3"</span> <span class="nt">-line</span> <span class="s2">":memory:"</span> <span class="s2">"PRAGMA compile_options;"</span>
<span class="c"># 출력에 ENABLE_FTS5 가 보이면 OK</span>
</code></pre></div></div>

<h3 id="간단-실전-테스트">간단 실전 테스트</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">/bin/sqlite3"</span> <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">SQL</span><span class="sh">'
CREATE VIRTUAL TABLE t USING fts5(content);
INSERT INTO t(content) VALUES ('hello world'), ('hello sqlite'), ('fts5 works');
SELECT rowid, content FROM t WHERE t MATCH 'hello';
</span><span class="no">SQL
</span></code></pre></div></div>

<h2 id="python-쪽도-되는지-확인">Python 쪽도 되는지 확인</h2>

<p><code class="language-plaintext highlighter-rouge">rpath</code> 또는 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>가 이미 잡혀 있다면, <strong>Python은 자동으로 새 libsqlite3.so</strong> 를 사용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python - <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">PY</span><span class="sh">'
import sqlite3
con = sqlite3.connect(':memory:')
con.execute("CREATE VIRTUAL TABLE t USING fts5(content)")
con.executemany("INSERT INTO t(content) VALUES (?)", [('hello world',), ('hello sqlite',), ('fts5 works',)])
print(list(con.execute("SELECT rowid, content FROM t WHERE t MATCH 'hello'")))
</span><span class="no">PY
</span></code></pre></div></div>

<h2 id="참고-옵션">참고 (옵션)</h2>

<ul>
  <li>JSON 함수도 필요하면 다음처럼 같이 켤 수 있어요:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O2 -fPIC"</span> ./configure <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SQLITE_PREFIX</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">--enable-shared</span> <span class="nt">--disable-static</span> <span class="se">\</span>
  <span class="nt">--enable-fts5</span> <span class="nt">--enable-json1</span>
</code></pre></div>    </div>
  </li>
  <li><strong>재빌드 후 Python 재설치는 불필요</strong> 합니다. 단, <strong>다른 경로</strong> 에 설치했다면 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>나 <code class="language-plaintext highlighter-rouge">-Wl,-rpath,&lt;경로&gt;</code>로 새 경로를 보이게 해야 해요.</li>
</ul>

<p>필요하면 위 과정을 <strong>한 번에 도는 짧은 스크립트</strong> 로 묶어 드릴게요.</p>

<p class="chat--user">

OperationalError: table embeddings already exists

</p>

<p>오류 메시지 그대로 해석하면, 지금 사용 중인 SQLite DB 안에 <strong><code class="language-plaintext highlighter-rouge">embeddings</code> 테이블이 이미 있어서</strong> 새로 만드는 쿼리(아마 <code class="language-plaintext highlighter-rouge">CREATE TABLE embeddings (...)</code>)가 다시 실행되며 터진 겁니다. 보통 ① 같은 DB 파일을 두 번 초기화했거나, ② 예전 데이터가 남아 있는데 마이그레이션 로직이 <code class="language-plaintext highlighter-rouge">IF NOT EXISTS</code> 없이 실행될 때 생겨요.</p>

<p>아래 중 편한 걸로 해결하세요 — “에러만 안 나게” 기준으로 <strong>가장 빨리 끝나는 순서</strong> 예요.</p>

<hr />

<h2 id="1-가장-빠름-새-데이터-디렉터리db로-시작">1) 가장 빠름: 새 데이터 디렉터리/DB로 시작</h2>

<p>(Open WebUI/Chroma가 쓰는 <strong>데이터 폴더</strong> 만 새로 쓰면 바로 해결)</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 예: Open WebUI를 새 데이터 폴더로</span>
open-webui serve <span class="nt">--data-dir</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/openwebui-data-clean"</span>
</code></pre></div></div>

<p>혹은(Chroma를 직접 쓰는 경우):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Chroma 영속 디렉터리를 새로</span>
<span class="nb">export </span><span class="nv">CHROMA_PERSIST_DIRECTORY</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/chroma-data-clean"</span>
<span class="c"># 앱/스크립트 재실행</span>
</code></pre></div></div>

<blockquote>
  <p>장점: 기존 파일 건드리지 않음.<br />
 단점: 이전 대화/인덱스는 새 폴더로 분리됨(필요하면 나중에 옮길 수 있음).</p>
</blockquote>

<hr />

<h2 id="2-기존-db에서-해당-테이블만-삭제">2) 기존 DB에서 해당 테이블만 삭제</h2>

<p>“그 DB 파일을 그대로 쓰되, 충돌 테이블만 정리”하는 방법입니다. (데이터가 날아갈 수 있으니 <strong>진짜 필요 없을 때만</strong>)</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># DB 파일 위치 파악</span>
<span class="c"># (예: open-webui의 --data-dir 안, chroma.sqlite / chroma.db / app.db 등)</span>
<span class="c"># 못 찾겠으면:</span>
<span class="c"># find "$HOME" -maxdepth 3 -type f \( -name "*.db" -o -name "*.sqlite*" \)</span>

<span class="c"># 스키마 확인</span>
sqlite3 /path/to/your.db <span class="s2">".tables"</span>
sqlite3 /path/to/your.db <span class="s2">".schema embeddings"</span>

<span class="c"># 정말 삭제해도 되는지 건수 확인</span>
sqlite3 /path/to/your.db <span class="s2">"SELECT COUNT(*) FROM embeddings;"</span>

<span class="c"># 삭제 (주의: 복구 어려움)</span>
sqlite3 /path/to/your.db <span class="s2">"DROP TABLE embeddings;"</span>
</code></pre></div></div>

<p>그 다음 앱을 다시 실행해 보세요. 초기화/마이그레이션 단계에서 테이블을 다시 만들 겁니다.</p>

<hr />

<h2 id="3-코드설정-쪽에서-이미-있으면-건너뛰기">3) 코드/설정 쪽에서 “이미 있으면 건너뛰기”</h2>

<p>만약 <strong>직접 작성한 스크립트</strong> 가 테이블을 만드는 거라면, 쿼리를 바꿔주세요:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql

CREATE TABLE IF NOT EXISTS embeddings ( ... );
</code></pre></div></div>

<p>(가상 테이블 FTS5의 경우엔 <code class="language-plaintext highlighter-rouge">CREATE VIRTUAL TABLE IF NOT EXISTS</code> 지원 버전이 제한적일 수 있으니, 확실히 하려면 실행 전에 존재 여부를 체크해서 분기하세요.)</p>

<hr />

<h3 id="체크-포인트-왜-다시-생겼는지">체크 포인트 (왜 다시 생겼는지)</h3>

<ul>
  <li>
    <p><strong>같은 DB 파일을 두 프로세스가</strong> 각각 “초기화” 로직으로 시작 → 충돌.</p>
  </li>
  <li>
    <p>예전 버전/다른 앱이 같은 DB 파일을 사용 → 스키마 이름 겹침.</p>
  </li>
  <li>
    <p>마이그레이션 스크립트에 <code class="language-plaintext highlighter-rouge">IF NOT EXISTS</code>가 빠짐.</p>
  </li>
</ul>

<hr />

<p>필요하면 지금 쓰는 <strong>DB 파일 경로를 같이 점검</strong> 하고, “드랍 vs 새 폴더로 시작” 중 어떤 게 안전한지 바로 판단해 드릴게요. 사용 중인 데이터 디렉터리/DB 파일 경로만 알려주면 됩니다.</p>

<p class="chat--user">

openwebui를 분리된 공간망에서 서비스할거야. 뭐 따로 옵션을 주거나 해야할 것 있어?

</p>

<p>좋아—<strong>분리된 폐쇄망(air‑gapped/내부망)</strong>에서 Open WebUI를 안정적으로 돌릴 때 “꼭 챙기면 좋은 옵션”만 딱 정리해 줄게. 전부 pip 실행 기준이지만 Docker/쿠버네티스도 동일한 ENV 개념이야.</p>

<hr />

<h2 id="핵심만-6줄-요약">핵심만 6줄 요약</h2>

<ol>
  <li>
    <p><strong>OFFLINE_MODE</strong> 켜서 버전체크/외부 다운로드 비활성화</p>
  </li>
  <li>
    <p><strong>내부 도메인으로 WEBUI_URL</strong> 지정(SSO/리다이렉트용)</p>
  </li>
  <li>
    <p><strong>회원가입/권한 통제</strong> : ENABLE_SIGNUP, DEFAULT_USER_ROLE</p>
  </li>
  <li>
    <p><strong>웹검색/RAG 외부 호출</strong> 을 꺼두거나 내부 검색엔진만 허용</p>
  </li>
  <li>
    <p><strong>모델/임베딩</strong> 은 미리 캐시(모델 파일을 내부 경로에 준비)</p>
  </li>
  <li>
    <p><strong>PersistentConfig 주의</strong> : 처음 값이 DB에 저장됨(바꾸려면 UI에서 수정)</p>
  </li>
</ol>

<p>이게 전부야. 아래에 바로 쓸 수 있는 예시 붙일게.</p>

<hr />

<h2 id="최소-권장-환경변수-폐쇄망-안전판">최소 권장 환경변수 (폐쇄망 안전판)</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1) 오프라인 모드: 버전 체크/허깅페이스 자동 다운 등 비활성화</span>
<span class="nb">export </span><span class="nv">OFFLINE_MODE</span><span class="o">=</span>True  <span class="c"># 오프라인 동작 가이드에 명시됨 :contentReference[oaicite:0]{index=0}</span>

<span class="c"># 2) 내부 URL 명시(SSO/리다이렉트, 일부 기능에서 필수)</span>
<span class="nb">export </span><span class="nv">WEBUI_URL</span><span class="o">=</span><span class="s2">"https://openwebui.internal.example"</span>  <span class="c"># PersistentConfig 항목 :contentReference[oaicite:1]{index=1}</span>

<span class="c"># 3) 사용자 만들기 정책</span>
<span class="nb">export </span><span class="nv">ENABLE_SIGNUP</span><span class="o">=</span>False                  <span class="c"># 신규 가입 막기(초기 관리자만) :contentReference[oaicite:2]{index=2}</span>
<span class="nb">export </span><span class="nv">DEFAULT_USER_ROLE</span><span class="o">=</span><span class="s2">"pending"</span>          <span class="c"># 가입 허용 시에도 기본은 보류 권장 :contentReference[oaicite:3]{index=3}</span>

<span class="c"># 4) 웹검색 완전 차단(기본 False지만, 명시해 두면 좋음)</span>
<span class="nb">export </span><span class="nv">ENABLE_WEB_SEARCH</span><span class="o">=</span>False              <span class="c"># 웹검색 토글(퍼시스턴트) :contentReference[oaicite:4]{index=4}</span>

<span class="c"># 5) CORS/쿠키(내부 HTTPS라면 Secure 쿠키 사용 권장)</span>
<span class="nb">export </span><span class="nv">CORS_ALLOW_ORIGIN</span><span class="o">=</span><span class="s2">"https://openwebui.internal.example"</span>  <span class="c"># 기본은 * → 내부만 허용으로 조이기 :contentReference[oaicite:5]{index=5}</span>
<span class="nb">export </span><span class="nv">WEBUI_AUTH_COOKIE_SECURE</span><span class="o">=</span>True        <span class="c"># 내부망이더라도 HTTPS면 True 권장 :contentReference[oaicite:6]{index=6}</span>

<span class="c"># 6) 데이터 경로(영속)</span>
<span class="nb">export </span><span class="nv">DATA_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/.open-webui"</span>         <span class="c"># 데이터 영속 경로 권장 설정 문서에 언급 :contentReference[oaicite:7]{index=7}</span>

<span class="c"># (pip 실행)</span>
open-webui serve <span class="nt">--port</span> 8080
</code></pre></div></div>

<blockquote>
  <p>참고: <strong>OFFLINE_MODE=True</strong> 로 두면 자동 업데이트 체크/임베딩 모델 자동 다운로드 등이 꺼지고, 오프라인에서도 오류 없이 동작하도록 보호해줘. 단, 외부 API·OAuth·웹검색 자체를 “기능적으로 막는” 스위치는 아니야. 네가 직접 끄거나 내부 리소스로만 연결해야 해. <a href="https://docs.openwebui.com/tutorials/offline-mode/">Open WebUI</a></p>
</blockquote>

<hr />

<h2 id="선택-내부-검색툴만-허용하고-싶다면">(선택) 내부 검색/툴만 허용하고 싶다면</h2>

<ul>
  <li>
    <p><strong>웹검색 완전 금지</strong> : <code class="language-plaintext highlighter-rouge">ENABLE_WEB_SEARCH=False</code> 유지. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
  <li>
    <p><strong>내부 SearXNG만 사용</strong> : 자체 SearXNG를 세워서</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">ENABLE_WEB_SEARCH</span><span class="o">=</span>True
<span class="nb">export </span><span class="nv">WEB_SEARCH_ENGINE</span><span class="o">=</span>searxng
<span class="nb">export </span><span class="nv">SEARXNG_QUERY_URL</span><span class="o">=</span><span class="s2">"http://searxng.internal/search?q=&lt;query&gt;&amp;format=json"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>처럼 내부 엔드포인트만 쓰게 해도 돼. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>

<hr />

<h2 id="선택-내부-llm-엔드포인트만-쓰기">(선택) 내부 LLM 엔드포인트만 쓰기</h2>

<p>OpenAI‑호환 서버(예: 사내 vLLM/LM Studio/프록시 등)를 <strong>Connections</strong> 에서 추가하면 돼. Base URL을 내부 주소로만 잡으면 외부로 못 나가. 가이드는 “OpenAI/호환 서버 시작하기”에 있어. <a href="https://docs.openwebui.com/getting-started/quick-start/starting-with-openai/?utm_source=chatgpt.com">Open WebUI+1</a></p>

<hr />

<h2 id="임베딩whisper-같은-모델은-사전-캐시">임베딩/Whisper 같은 모델은 “사전 캐시”</h2>

<p>오프라인 모드에선 허깅페이스에서 <strong>자동 다운로드가 막히므로</strong> , 모델 파일을 <strong>미리</strong> 받아서 Open WebUI 캐시 경로에 넣어둬야 해:</p>

<ul>
  <li>
    <p>임베딩 모델: <code class="language-plaintext highlighter-rouge">/app/backend/data/cache/embedding/models/</code></p>
  </li>
  <li>
    <p>whisper: <code class="language-plaintext highlighter-rouge">/app/backend/data/cache/whisper/models/</code><br />
환경변수로 디폴트 모델도 지정 가능(<code class="language-plaintext highlighter-rouge">RAG_EMBEDDING_MODEL</code>, <code class="language-plaintext highlighter-rouge">WHISPER_MODEL</code>). <a href="https://docs.openwebui.com/tutorials/offline-mode/">Open WebUI</a></p>
  </li>
</ul>

<hr />

<h2 id="보안운영-팁필요한-것만">보안/운영 팁(필요한 것만)</h2>

<ul>
  <li>
    <p><strong>첫 계정이 관리자</strong> : 초기 셋업 때 만든 첫 계정이 Admin이라 사용자 승인/정책을 제어할 수 있어. <a href="https://docs.openwebui.com/getting-started/quick-start/?utm_source=chatgpt.com">Open WebUI</a></p>
  </li>
  <li>
    <p><strong>API 키 제어</strong> : 필요하면 <strong>API Key Endpoint Restrictions</strong> 로 허용 엔드포인트를 제한할 수 있어(내부 API만 허용 목록으로). <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
  <li>
    <p><strong>PersistentConfig 주의</strong> : <code class="language-plaintext highlighter-rouge">ENABLE_SIGNUP</code>, <code class="language-plaintext highlighter-rouge">WEBUI_URL</code> 등은 <strong>처음 값이 내부 DB에 저장</strong> 돼. 나중에 바꾸려면 Admin UI에서 수정하거나 <code class="language-plaintext highlighter-rouge">ENABLE_PERSISTENT_CONFIG=False</code>로 일시 해제 후 적용. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
  <li>
    <p><strong>프록시가 있는 내부망</strong> : 웹로더/웹검색이 내부 프록시만 통과하도록 <code class="language-plaintext highlighter-rouge">http_proxy/https_proxy/no_proxy</code>를 지원해. <a href="https://docs.openwebui.com/getting-started/env-configuration/">Open WebUI</a></p>
  </li>
</ul>

<hr />

<h2 id="체크리스트-진짜-최소">체크리스트 (진짜 최소)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OFFLINE_MODE=True</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WEBUI_URL</code>을 내부 도메인으로 지정</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ENABLE_SIGNUP=False</code> 또는 기본 권한을 <code class="language-plaintext highlighter-rouge">pending</code>으로</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ENABLE_WEB_SEARCH=False</code>(또는 내부 SearXNG로 한정)</p>
  </li>
  <li>
    <p>임베딩/Whisper 모델 <strong>사전 캐시</strong> 완료</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DATA_DIR</code>로 영속 경로 지정</p>
  </li>
</ul>

<p>원하면 네 환경 변수/내부 엔드포인트에 맞춘 <strong>한 줄 실행 스크립트</strong>(pip용)를 바로 만들어 줄게.</p>

<p class="chat--user">

기본 포트 번호가 뭐야

</p>

<p>pip로 설치해서 <code class="language-plaintext highlighter-rouge">open-webui serve</code>로 실행하면 <strong>기본 포트는 8080</strong> 이에요.</p>

<ul>
  <li>
    <p>그래서 브라우저에서 <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>으로 접속하면 됩니다.</p>
  </li>
  <li>
    <p>포트를 바꾸고 싶으면:</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open-webui serve <span class="nt">--port</span> 3000
</code></pre></div></div>

<p>처럼 <code class="language-plaintext highlighter-rouge">--port</code> 옵션을 주면 돼요.</p>

<p class="chat--user">

endpoint로 모델 추가하는 법

</p>

<p>오케이—엔드포인트를 이미 알고 있다는 전제로, <strong>Open WebUI에 모델(프로바이더) 추가</strong> 하는 가장 쉬운 방법을 빠르게 정리할게요. (pip 설치 기준, 폐쇄망도 OK)</p>

<hr />

<h2 id="1-ui에서-추가-가장-간단">1) UI에서 추가 (가장 간단)</h2>

<ol>
  <li>
    <p>브라우저에서 Open WebUI 접속 → <strong>Settings → Models → Providers</strong></p>
  </li>
  <li>
    <p><strong>Add Provider</strong> 클릭 → 유형에서 <strong>OpenAI Compatible</strong>(또는 <strong>Ollama</strong>) 선택</p>
  </li>
  <li>
    <p>입력:</p>

    <ul>
      <li>
        <p><strong>Base URL</strong> : 예) <code class="language-plaintext highlighter-rouge">http://&lt;host&gt;:&lt;port&gt;/v1</code></p>
      </li>
      <li>
        <p><strong>API Key</strong> : 엔드포인트 키 (필요 없으면 빈 값/토큰형식에 맞게)</p>
      </li>
      <li>
        <p>(옵션) <strong>Custom Headers</strong> : 사내 프록시/게이트웨이에서 헤더 요구 시 추가</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Save</strong> → <strong>Refresh/Sync models</strong>(모델 목록 새로고침)</p>

    <ul>
      <li>목록이 비면 “<strong>Model name</strong> ”을 직접 입력해 수동으로 추가(엔진이 노출하는 정확한 모델 ID 필요)</li>
    </ul>
  </li>
  <li>
    <p>원하는 모델에 <strong>Set as default</strong>(기본 모델 지정)</p>
  </li>
</ol>

<blockquote>
  <p>vLLM/LM Studio/프록시류는 대부분 <code class="language-plaintext highlighter-rouge">…/v1</code>가 Base URL이고, 모델 ID는 서버가 가진 이름 그대로 써야 목록에 잘 뜹니다.</p>
</blockquote>

<hr />

<h2 id="2-환경변수로-미리-박아두고-실행-초기-자동-설정">2) 환경변수로 미리 박아두고 실행 (초기 자동 설정)</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># OpenAI-호환 엔드포인트 예시</span>
<span class="nb">export </span><span class="nv">OPENAI_API_BASE_URL</span><span class="o">=</span><span class="s2">"http://&lt;host&gt;:&lt;port&gt;/v1"</span>
<span class="nb">export </span><span class="nv">OPENAI_API_KEY</span><span class="o">=</span><span class="s2">"sk-xxxxxxxx"</span>   <span class="c"># 필요 없으면 생략 가능</span>
open-webui serve <span class="nt">--port</span> 8080
</code></pre></div></div>

<ul>
  <li>
    <p>실행 후 <strong>Settings → Models</strong> 에 들어가면 위 값이 반영되어 있음.</p>
  </li>
  <li>
    <p>여러 엔드포인트를 쓰려면 UI에서 프로바이더를 추가로 더 등록하세요.</p>
  </li>
</ul>

<hr />

<h2 id="3-선택-ollama-전용">3) (선택) Ollama 전용</h2>

<ul>
  <li>
    <p>UI에서 <strong>Ollama</strong> 유형 선택 후 <strong>Base URL</strong> : <code class="language-plaintext highlighter-rouge">http://&lt;host&gt;:11434</code></p>
  </li>
  <li>
    <p>또는</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">OLLAMA_BASE_URL</span><span class="o">=</span><span class="s2">"http://&lt;host&gt;:11434"</span>
open-webui serve
</code></pre></div></div>

<hr />

<h2 id="4-연결-전-엔드포인트-정상인지-빠른-자가테스트">4) 연결 전 “엔드포인트 정상인지” 빠른 자가테스트</h2>

<h3 id="모델-목록-확인-openai-호환-표준">모델 목록 확인 (OpenAI 호환 표준)</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-sS</span> <span class="nt">-H</span> <span class="s2">"Authorization: Bearer </span><span class="nv">$OPENAI_API_KEY</span><span class="s2">"</span> <span class="se">\</span>
  &lt;BASE_URL&gt;/models
</code></pre></div></div>

<ul>
  <li>
    <p>200 OK + 모델 리스트가 나오면 OK.</p>
  </li>
  <li>
    <p>에러면 <strong>Base URL 끝에<code class="language-plaintext highlighter-rouge">/v1</code> 누락</strong>, 키/헤더, CORS/프록시 등을 점검.</p>
  </li>
</ul>

<hr />

<h2 id="5-흔한-이슈--바로-해결">5) 흔한 이슈 &amp; 바로 해결</h2>

<ul>
  <li>
    <p><strong>모델이 안 뜸</strong> :</p>

    <ul>
      <li>
        <p>Base URL이 <code class="language-plaintext highlighter-rouge">/v1</code>인지 확인</p>
      </li>
      <li>
        <p>내부망이면 <strong>모델 리스트 캐시</strong> 때문에 안 보일 수 → Settings에서 <strong>Refresh/Sync</strong></p>
      </li>
      <li>
        <p>그래도 안 뜨면 <strong>모델 ID 수동 입력</strong>(서버에서 쓰는 정확한 이름)</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>401/403</strong> : 키 또는 커스텀 헤더 불일치. 게이트웨이가 요구하는 헤더를 <strong>Custom Headers</strong> 에 추가.</p>
  </li>
  <li>
    <p><strong>연결은 되는데 응답 에러</strong> :</p>

    <ul>
      <li>
        <p>엔진이 OpenAI Chat Completions 스펙 지원하는지 확인(vLLM/LM Studio는 보통 지원)</p>
      </li>
      <li>
        <p><strong>timeout</strong> 늘리기(서버가 느릴 때)</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>폐쇄망</strong> : 외부 검색/다운로드가 필요 없게</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">ENABLE_WEB_SEARCH=False</code>, <code class="language-plaintext highlighter-rouge">OFFLINE_MODE=True</code></p>
      </li>
      <li>
        <p>임베딩/Whisper 모델은 <strong>미리 캐시</strong>(필요 시)</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="6-최소-예시가장-흔한-vllmlm-studio">6) 최소 예시(가장 흔한 vLLM/LM Studio)</h2>

<ul>
  <li>
    <p>Base URL: <code class="language-plaintext highlighter-rouge">http://10.0.0.5:8000/v1</code></p>
  </li>
  <li>
    <p>API Key: (없으면 비움)</p>
  </li>
  <li>
    <p>모델 ID: 서버가 노출하는 이름(예: <code class="language-plaintext highlighter-rouge">Meta-Llama-3-8B-Instruct</code>)</p>
  </li>
  <li>
    <p>저장 → Refresh → 기본 모델로 지정</p>
  </li>
</ul>

<hr />

<p>필요하면 <strong>당신이 가진 엔드포인트/모델ID/키 형식</strong> 에 맞춰서,<br />
한 번에 붙는 <strong>환경변수 스니펫</strong> 이나 <strong>UI 입력값 표</strong> 를 맞춤으로 뽑아줄게.</p>

<p class="chat--user">

모델 목록 새로고침은 어디있어?

</p>

<p>Open WebUI에서 <strong>모델 목록 새로고침(Refresh/Sync)</strong> 버튼은 <strong>Settings → Models</strong> 화면에 있습니다.</p>

<p>정확히는 이렇게 찾으면 돼요:</p>

<ol>
  <li>
    <p><strong>브라우저에서 Open WebUI 접속</strong></p>
  </li>
  <li>
    <p>좌측 메뉴에서 <strong>⚙ Settings</strong> 클릭</p>
  </li>
  <li>
    <p>상단 탭 중에서 <strong>Models</strong> 선택<br />
(여기서 이미 등록한 Provider들이 보입니다)</p>
  </li>
  <li>
    <p>각 Provider 카드(예: "OpenAI Compatible") 오른쪽 위에 <strong>⟳</strong> 아이콘(또는 "Refresh"/"Sync Models" 버튼)이 있어요.</p>
  </li>
  <li>
    <p>클릭하면 해당 엔드포인트에 <code class="language-plaintext highlighter-rouge">/models</code> 요청을 보내서 새로 모델 목록을 불러옵니다.</p>
  </li>
</ol>

<p>💡 참고:</p>

<ul>
  <li>
    <p>새로고침 후에도 목록에 안 뜨면, 해당 엔드포인트가 <strong>/models</strong> 응답에 모델 ID를 반환하지 않는 경우일 수 있습니다.<br />
이럴 땐 <strong>"Add model"</strong> 기능으로 모델 ID를 수동으로 넣어줘야 해요.</p>
  </li>
  <li>
    <p>목록 캐시는 내부적으로 TTL이 있어서, 버튼 없이도 일정 시간 지나면 갱신되지만, 수동으로 바로 보고 싶으면 여기서 눌러주면 됩니다.</p>
  </li>
</ul>

<hr />

<p>원하면 내가 UI 스크린샷처럼 생긴 구조를 그려서, <strong>Refresh 버튼이 정확히 어디 있는지</strong> 바로 보이게 해줄까요?<br />
그러면 한 번에 찾을 수 있을 거예요.</p>

<p class="chat--user">

이거 서버 꺼도 설정은 저장되지?

</p>

<p>네, <strong>서버 꺼도 설정은 저장됩니다.</strong></p>

<p>Open WebUI는 설정(모델 엔드포인트, 사용자 계정, UI 환경설정 등)을 <strong>백엔드 데이터베이스</strong> 에 저장합니다.</p>

<ul>
  <li>
    <p>pip 설치 시 기본 경로: <code class="language-plaintext highlighter-rouge">~/.open-webui</code> (또는 <code class="language-plaintext highlighter-rouge">--data-dir</code>로 지정한 경로)</p>
  </li>
  <li>
    <p>Docker 실행 시: <code class="language-plaintext highlighter-rouge">/app/backend/data</code> 볼륨</p>
  </li>
</ul>

<p>여기 안에는 SQLite DB(<code class="language-plaintext highlighter-rouge">app.db</code>), 캐시, 업로드 파일 등이 들어 있고,<br />
서버를 꺼도 이 디렉터리만 유지되면 다음 실행 시 그대로 복원됩니다.</p>

<hr />

<p>📌 <strong>주의할 점</strong></p>

<ul>
  <li>
    <p>Docker로 띄울 땐 <strong>볼륨 마운트</strong> 안 하면 컨테이너 삭제 시 데이터도 같이 날아갑니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ENABLE_PERSISTENT_CONFIG=True</code>(기본값)일 때는 환경변수 값도 최초 기동 시점에 DB에 저장돼서, 이후 서버 재시작해도 DB 값이 우선됩니다.</p>
  </li>
  <li>
    <p>설정 초기화하고 싶으면 <code class="language-plaintext highlighter-rouge">--data-dir</code> 새로 지정하거나 <code class="language-plaintext highlighter-rouge">app.db</code>만 지우면 됩니다.</p>
  </li>
</ul>

<hr />

<p>원하면 내가 <strong>현재 Open WebUI가 설정 저장하는 경로를 확인하는 방법</strong> 도 알려줄게.<br />
그러면 껐다 켜도 그대로 유지되는지 바로 테스트할 수 있어요.</p>

<p class="chat--user">

아레나 모델은 뭐야?

</p>

<p>아, “Arena Model(Arena 모드)”에 대해 물어보신 거군요! Open WebUI에서 제공하는 <strong>모델 평가 기능</strong> 으로, <strong>A/B 테스팅</strong> 을 쉽게 할 수 있는 모드입니다.</p>

<hr />

<h2 id="arena-model이란">Arena Model이란?</h2>

<ul>
  <li>
    <p><strong>여러 모델을 묶은 그룹</strong> 에서 <strong>무작위로 하나를 선택</strong> 해 응답을 생성하는 모드입니다. <a href="https://docs.openwebui.com/features/evaluation/?utm_source=chatgpt.com">Open WebUI+10</a><a href="https://github.com/open-webui/open-webui/discussions/6538?utm_source=chatgpt.com">GitHub</a></p>
  </li>
  <li>
    <p>생성된 응답에는 <strong>어떤 모델이 썼는지 숨겨진 상태</strong> 여서, <strong>블라인드 테스트</strong> 처럼 비교할 수 있어요.</p>
  </li>
  <li>
    <p>내가 그 응답에 "<strong>좋아요/싫어요</strong> "를 누르면, 어떤 모델이 썼는지 나중에 확인할 수 있고, 리더보드를 통해 <strong>모델 간 성능 순위</strong> 를 확인할 수 있습니다. <a href="https://docs.openwebui.com/features/evaluation/?utm_source=chatgpt.com">Open WebUI</a><a href="https://github.com/open-webui/open-webui/discussions/6538?utm_source=chatgpt.com">GitHub</a></p>
  </li>
</ul>

<hr />

<h2 id="arena-model-사용법-요약">Arena Model 사용법 요약</h2>

<ol>
  <li>
    <p><strong>Admin Panel → Settings → Evaluations</strong> 에서 <strong>Arena Model</strong> 그룹을 설정합니다.</p>
  </li>
  <li>
    <p>평가에 포함할 모델들을 선택해 그룹에 추가합니다.</p>
  </li>
  <li>
    <p>챗 화면에서 <strong>Arena Model</strong> 을 선택하면, 랜덤으로 모델이 하나 뽑혀 응답 생성.</p>
  </li>
  <li>
    <p>응답에 <strong>좋아요/싫어요</strong> 클릭 → 뒤에 어떤 모델이 답했는지 확인 가능.</p>
  </li>
  <li>
    <p>리더보드를 통해 각 모델의 비교 성능을 시각화할 수 있습니다. <a href="https://docs.openwebui.com/features/evaluation/?utm_source=chatgpt.com">Open WebUI+5</a></p>
  </li>
</ol>

<hr />

<h2 id="왜-유용할까">왜 유용할까?</h2>

<ul>
  <li>
    <p><strong>편견 없는 비교</strong> : 사용자가 모델 이름을 몰라서 선입견 없이 평가 가능.</p>
  </li>
  <li>
    <p><strong>행동 기반 선호</strong> : 좋아요/싫어요가 자동으로 더 좋은 모델을 띄워줌.</p>
  </li>
  <li>
    <p><strong>리더보드 제공</strong> : 설정한 모델 그룹 내에서 <strong>어떤 모델이 강한지 한눈에 확인 가능</strong>.</p>
  </li>
</ul>

<hr />

<p>필요하시면, <strong>관리자 설정 화면 스크린샷</strong> , 혹은 실제 Arena Model을 켜고 사용하는 예시 절차 스크립트까지 만들어드릴 수 있어요. 필요하신가요?</p>

        
      </section>

      <footer class="page__meta">
        
        


  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#llm" class="page__taxonomy-item p-category" rel="tag">llm</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-08-12T19:21:35+09:00">2025-08-12</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/llm/reasoning-effort-test/" class="pagination--pager" title="Reasoning effort 실험 계획">Previous</a>
    
    
      <a href="/verilog/pyverilog-ir/" class="pagination--pager" title="PyVerilog AST 변환">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">You may also enjoy</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/2025-08-19-python-repr-vs-str/" rel="permalink">
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <!-- hvppyarchive: remove date icon
        <i class="far fa-calendar-alt" aria-hidden="true"></i> 
        -->
        
        <time datetime="2025-10-02T12:45:03+09:00">2025-10-02</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/comfyui/comfyui-custom-node-config/" rel="permalink">ComfyUI 설정 파일 개발
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <!-- hvppyarchive: remove date icon
        <i class="far fa-calendar-alt" aria-hidden="true"></i> 
        -->
        
        <time datetime="2025-10-02T12:44:58+09:00">2025-10-02</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/python/openai-package-data-hook/" rel="permalink">openai api Raw 데이터 확인 방법
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <!-- hvppyarchive: remove date icon
        <i class="far fa-calendar-alt" aria-hidden="true"></i> 
        -->
        
        <time datetime="2025-10-01T18:38:56+09:00">2025-10-01</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/python/pickle-to-json/" rel="permalink">Pickle to JSON 변환
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <!-- hvppyarchive: remove date icon
        <i class="far fa-calendar-alt" aria-hidden="true"></i> 
        -->
        
        <time datetime="2025-09-29T10:41:41+09:00">2025-09-29</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2013 - 2025 <a href="https://hvppyarchive.github.io">ARCHIVE</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
